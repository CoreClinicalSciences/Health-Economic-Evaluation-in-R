[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Decision Modelling for Health Economic Evaluation in R",
    "section": "",
    "text": "Purpose of This e-Book\nThe Decision Modelling for Health Economic Evaluation, is an important book and likely an introductory book for those who want to learn about health economic modelling\nSay this e book is intended to supplement readers who want to learn how to apply the concepts illustrated in the book in R instead of Excel.\nThis ebook contains mostly supporting materials in R, instead of Excel that is available here (https://www.herc.ox.ac.uk/downloads/decision-modelling-for-health-economic-evaluation).",
    "crumbs": [
      "Purpose of This e-Book"
    ]
  },
  {
    "objectID": "Chapters/1-Introduction.html",
    "href": "Chapters/1-Introduction.html",
    "title": "1  Chapter 1",
    "section": "",
    "text": "blah",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Chapter 1</span>"
    ]
  },
  {
    "objectID": "Chapters/Appendix-1-Codes.html",
    "href": "Chapters/Appendix-1-Codes.html",
    "title": "2  Appendix",
    "section": "",
    "text": "blah",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "Chapters/Ch1-Introduction.html",
    "href": "Chapters/Ch1-Introduction.html",
    "title": "Chapter 1 - Introduction",
    "section": "",
    "text": "This book reviews the exercises in “Decision Modeling for Health Economic Evaluation” by Andrew Briggs, Karl Claxton, and Mark Sculpher. We aim to re-create all the exercises, which are originally written in Excel, in R. We provide a breakdown of how to perform the analyses in R, as well, as a discussion on the advantages and dis-advantages of moving from Excel to a scripting language like R.\nWe will first start off by reviewing some basic concepts in R that may be unfamiliar to the reader, even coming from another scripting language such as python. The introduction will review R’s vectorization, matrix multiplication, and vector operations.",
    "crumbs": [
      "Introduction",
      "Chapter 1 - Introduction"
    ]
  },
  {
    "objectID": "Exercises/Ch2-Exercise-25.html",
    "href": "Exercises/Ch2-Exercise-25.html",
    "title": "Exercise 2.5",
    "section": "",
    "text": "Preamble on matrix operations\nThis R markdown file reproduces exercise 2.5 in R from Chapter 2 of the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nWhen building markov molds and building transition matrices, using matrix-vector multiplications simplifies manual computation significantly.\nTo multiply a matrix by a vector we must have the same number of columns in the matrix as rows in a vector. Consider below an example of a two-state markov model and the goal is to discern the proportion left in the first state after two time cycles. We also show how to select rows and columns of a matrix.",
    "crumbs": [
      "Introduction",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Exercises/Ch2-Exercise-25.html#preamble-on-matrix-operations",
    "href": "Exercises/Ch2-Exercise-25.html#preamble-on-matrix-operations",
    "title": "Exercise 2.5",
    "section": "",
    "text": "Matrix multiplication example\nFirst, we will create our vector called iVec_example. The number of entries in this vector should be the same as the number of states. In this example we will assume that everyone starts in the first state.\nNote: the c() operation initializes a vector (it is considered by default a column vector)\n\niVec_example &lt;- c(1,0)\n\n\nBelow, we consider a two-state markov model. We build a 2 x 2 matrix of the transition probabilities:\n\ntProbs_example &lt;- matrix(c(0.7,0.3,\n                           0.1,0.9),\n                 nrow = 2, ncol = 2,\n                 byrow = T)\n\n\nNow, we want to calculate the proportion of individuals in the first time-cycle. The results will be saved in time1Prop\nNote: the number of columns in the matrix must match the number of rows in the vector.\n\ntime1Prop &lt;- tProbs_example %*% iVec_example\n\n\nTo get the proportion after the second-time we can multiply the first-time proportion that we just calculated by the transition probability matrix\n\ntime2Prop &lt;- tProbs_example %*% time1Prop\n\n\nWe can use the [i,j] operator to extract row i and column j of a matrix\n\ntProbs_example[1,] #extracts the first row\n\n[1] 0.7 0.3\n\ntProbs_example[,2] #extracts the second column\n\n[1] 0.3 0.9\n\ntProbs_example[1,2] #extracts first row and second column entry\n\n[1] 0.3\n\n\n\nWe can also use the -i operator to extract all except i\n\ntProbs_example[-1,]  #extracts all but the first row\n\n[1] 0.1 0.9\n\ntProbs_example[,-1]  #extracts all but the column\n\n[1] 0.3 0.9",
    "crumbs": [
      "Introduction",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Exercises/Ch2-Exercise-25.html#start-of-exercise-2.5",
    "href": "Exercises/Ch2-Exercise-25.html#start-of-exercise-2.5",
    "title": "Exercise 2.5",
    "section": "Start of Exercise 2.5",
    "text": "Start of Exercise 2.5\nFirst, we will calculate the monotherapy transition probabilities for the control based on the data provided in Table 2.5. These probabilities should match the transition probabilities provided in Table 2.2. part 1(a)\nWe need to calculate the following transition probabilities:\n\nTransition probability from A to A\nTransition probability from A to B\nTransition probability from A to C\nTransition probability from A to D\nTransition probability from B to B\nTransition probability from B to C\nTransition probability from B to D\nTransition probability from C to C\nTransition probability from C to D\n\n\nPart 1\nNow that we have calculated the transition probabilities, we will use these values to populate the transition probability matrix and initialize the parameters necessary for modelling.\nThe matrix will follow the structure below, as shown in table 2.6:\n\n#         To State\n#           A B C D\n# From    A\n# State   B\n#         C\n#         D\n\n\nAs you complete the matrix, remember, that it’s not possible to go backwards in this model, so any transition probability below the diagonal values will be 0.\n\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\n#please note that there are more decimals here than in Table 2.2a and other figures. This is because we aim to maintain the exact decimals used in the Excel sheet for consistency. To get decimals closer to what we achieve here, we recommend using Table 2.5 as a guide.\n\nCheck. We will use rowSums to make sure we’ve entered our transition matrix correctly. All the rows should equal 1\n\nrowSums(tProbs) \n\n[1] 1 1 1 1\n\n\n\nNow, we will fill in other parameters that are provided in the exercise. After each parameter, we’ve used # and a description of what that parameter is so we can easily revisit our code at a future date.\n\n#costs\ndmca &lt;- 1701 #direct medical cost of A\ndmcb &lt;- 1774 #direct medical cost of B\ndmcc &lt;- 6948 #direct medical cost of C\nccca &lt;- 1055 #community care cost of A\ncccb &lt;- 1278 #community care cost of B\ncccc &lt;- 2059 #community care cost of C\ncAZT &lt;- 2278 #cost of Zidovudine\ncLam &lt;- 2086.5 #cost of Lamivudine \n\n#other parameters\nRR &lt;- 0.509 #relative risk of treatment\ncDR &lt;- 0.06 #annual discount rate cost (proportion)\noDR &lt;- 0 #annual discount rate benefits (proportion)\n\n\n\nPart 2\nNow, we will calculate the proportion of individuals in each state for years 1-20 (Monotherapy), their life-years, and associated costs.\nWe will input the initial vector for the state space, where each element refers to the initial proportion of individuals in state A-D respectively.\nWe assume all individuals start in State A. We are giving the vector the name iVec.\n\niVec &lt;-  c(1,0,0,0)\n\nWe are going to create a funcation called calculateYearlyProbs that we can use to calculate the proportion of people in each state at a given time point.\nThis function will return a t (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #Loop through all time-points and multiply the vector by \n  for(i in 1:(t)){\n\n    matReturn[i,] &lt;-   iVec %*% tProbs\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n}\n\nNow, we will call the function, by entering our transition probabilities matrix, the number of years we want to calculate, and our starting vector as arguments. We’ve called the results of our function yearlyProbs. It will return a matrix that is 20 rows (years) long and 4 states wide.\n\nyearlyProbs &lt;- calculateYearlyProbs(tProbs,20,iVec)\n\nCheck. Use rowSums to check that all rows sum to 1\n\nrowSums(yearlyProbs)\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nNow we will calculate the number of life years for each year. This is equal to the the proportion that is not in State D (death).\n\nlifeYears &lt;- rowSums(yearlyProbs[,-4])\n\n\n\nPart 3\nUsing the cost inputs from before, we will calculate the cost. Then, based on those costs, we will calculate the discounted cost using the discounted cost formula provided in the text.\nTo calculate the non-discounted costs, we will calculate a cost associated with each health state in our markov model, and then create a vector to hold the costs associated with each state.\n\ncostA &lt;- dmca+ccca+cAZT\ncostB &lt;- dmcb+cccb+cAZT\ncostC &lt;- dmcc+cccc+cAZT\n\ncostVector &lt;- c(costA,costB,costC)\n\nWe will use matrix multiplication to calculate the non-discounted cost. We will multiply yearlyProbs, the matrix holding the proportion in each health state by cycle (i.e. year), by our new costVector.\nRemember, we need to make sure the vector and the matrix have the same number of columns. So, we will use [-4] to remove the death state column from the matrix.\n\nnonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\nOur non-discounted costs are saved in nonDiscCost. To get teh discounted cost, we will apply the discounting formula. We will create a discounting function that we can reuse in the future.\nSo we can apply this function to multiple values of t at once we will use R’s vectorization. All basic operations in R “-+^/*” support basic R vectorization.\nThis means we can use the discount formula for all values of t at once (t = 1,..,20). We can do this by using 1:t in place of “t” in the formula\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\nWe can calculate the discounted costs by filling in the arguments for the newly created discount function. We need to specify: the non-discounted costs; the discount rate; and the number of years you are calculating for.\n\ndiscCost &lt;- discountFormula(nonDiscCost, discRate = cDR,20)\n\nWe will use the sum function to calculate the total costs and life years over the 20 years of the Markov model.\n\ntotalDiscCostMonoTherapy &lt;- sum(discCost)\ntotalLifeYearsMonoTherapy &lt;- sum(lifeYears)\n\n\n\nPart 4\nHaving completed the analysis for the monotherapy, we will repeat the same steps for the combination therapy, with a few changes. Use table 2.2 part 1(b) as a guide to calculate the combination transition matrix. Recall that the combination therapy is only used for the first two years of treatment.\nTo begin, lets create a function that converts the original transition matrix to the combination transition matrix by using the risk ratio provided\n\ncalculateProbCombination &lt;- function(tProbs,RR = 0.506){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\nNow, we will use our function to calculate the transition probabilities for the combination therapy:\n\ntProbsComb &lt;- calculateProbCombination(tProbs,RR = RR)\n\nCheck. Just like before, we will use rowSums to check that all rows sum to 1\n\nrowSums(tProbsComb)\n\n[1] 1 1 1 1\n\n\nThen we will calculate the yearly proportions for the first two years using the function calculateYearlyProbs that we created above. The function arguments will include tProbsComb–the new proportions matrix for the combination therapy.\n\nprobsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n\nNow we will calculate the yearly proportions for years 3-20. We will use the transition probabilities for monotherapy for these calculations, reflecting that the combination therapy is only used in years 1 and 2. We will then combined the two calculations to get the values for years 1-20, and check that each row sums to 1.\n\nprobsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = 18,iVec =probsCombYearly1_2[2,])\n\n#combine them\nprobsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n\n#check\nrowSums(probsCombYearly) # all sum to 1\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nUsing the same approach as for the monotherapy, we will calculate the life years and the costs, being careful to apply the correct costs to the correct proportions.\n\n#calculate the life-years\nlifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n\n#calculate the costs\ncostAComb &lt;- costA+cLam\ncostBComb &lt;- costB+cLam\ncostCComb &lt;- costC+cLam\n#combine the costs into a vector\ncostVectorComb &lt;- c(costAComb,costBComb,costCComb)\n\n#use matrix multiplication\ncostCombNonDisc1_2 &lt;-   probsCombYearly[1:2,-4] %*% costVectorComb\ncostCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n\nWe will use rbind to combine the non-discounted costs and then use the discount function to calculate the discounted costs. With the costs and life years calculated for each year, we will use sum to calculate the total costs and life years associated with the combination therapy.\n\n#use rbind to combine the non-discounted cost\ncostCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n\n#calculate the discounted rate\ncostCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,20)\n\n#calculate the total costs and life years for the combination therapy\ntotalLifeYearsComb &lt;- sum(lifeYearsComb)\ntotalDiscCostComb &lt;- sum(costCombDisc)\n\n\n\nPart 5\nLastly, compare the total life years and costs between the monotherapy and combination therapy to calculate the ICER\n\n#combination over monotherapy\nlifeYearsGained &lt;- totalLifeYearsComb - totalLifeYearsMonoTherapy\nincreasedCost &lt;- totalDiscCostComb - totalDiscCostMonoTherapy\n\n#calculate ICER\nICER &lt;- increasedCost/lifeYearsGained\n\nICER \n\n[1] 6275.956",
    "crumbs": [
      "Introduction",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html",
    "href": "Exercises/Ch3-Exercise-35.html",
    "title": "Exercise 3.5",
    "section": "",
    "text": "Setup\nThis R markdown file reproduces exercise 3.5 in R from Chapter 3 of the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nThis exercise builds upon the skills from exercise 2.5. You will need to know how to build and call functions in R, as well as how to multiply matrices.\nThe following Markov Model will be used in this exercise. Use it to fill in the transition probabilities in the later section. This figure comes directly from the original Excel worksheet provided by Andrew Briggs, Mark Sculpher, and Karl Claxton.\nTo begin, we need to enter our parameter values. Some are are provided directly and some need to be calculated.\nBelow we enter the cost and utility parameters provided.\nmale &lt;- 0 #0 for female, 1 for male\nage &lt;- 60 #average age at receipt for primary implant\n\n#transition probabilities\n#these values are provided at the start of the guide on in section 3.5.2\nomrPTHR &lt;- 0.02 #operative mortality rate for primary THR\nomrRTHR &lt;- 0.02 #operative mortality rate for revision THR\nrrr &lt;- 0.04 #re-revision risk rate\n\n#costs\ncRevision &lt;- 5294 #cost of revisions\ncStandard &lt;- 394 #cost of standard implant\ncNP1 &lt;- 579 #cost of new implant\n\n#discount rates\ncDR &lt;- 0.06 #cost discount\noDR &lt;- 0.015 #outcome discount\n\n#utility of markov states\n#these values are given in Section 3.5.2 1) iii\nuSuccessP &lt;- 0.85 #utility of primary success\nuSuccessR &lt;- 0.75 #utility of revision success\nuRevision &lt;- 0.30 #utility of revision\nNow we will enter the survival model that is fit with a weibull distribution.\nRemember that the coefficients are on the log scale.\nsurvModelSummary &lt;- data.frame(\n  \n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nTo calculate lambda of the weibull distribution we can take the linear combination of the coefficients. Again, we need to remember to exponentiate the results as they are on the log scale.\nWe can use the $ operator to create new columns in the survModelSummary dataframe and extract any column from the dataframe by name. the $ operator by default extracts a vector, which means vector operations can be done on them such as [i] to extract the ith element of the vector. If you want to refresh your memory on how to use [i] to extract a data element, review exercise 2.5.\n#replace `columnname`\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n#use the $ operator to extract the column of choice then use [i] to extract the coeficient of choice\n#for example [2] corresponds to the constant coefficient \nlnLambda &lt;- survModelSummary$coefficient[2] + survModelSummary$coefficient[3]*age + survModelSummary$coefficient[4]*male\n\n#ensure to exponentiation lambda and gamma as they are in in the log scale\nlambda &lt;- exp(lnLambda)\ngamma &lt;- exp(survModelSummary$coefficient[1])",
    "crumbs": [
      "Introduction",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-2",
    "href": "Exercises/Ch3-Exercise-35.html#step-2",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.2 Step 2",
    "text": "2.2 Step 2\nUsing life-tables for background mortality\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n#note that by default this exercise uses Female. Lets create the death risk by analyzing the cycle for those who are female and have an average age of 60 plus the cycle year due to all cause mortality\n\n#we use a special function in R called the apply family. This function takes two arguments x and a function of x. This function is then applied to all elements of x. We can use this to extract the appropriate cell of the yearlyTProbs dataset for all 60 cycles. The apply function family is essentially a wrapper of a for-loop, that can be quickly written. If you prefer the equivalent code, it can be written as a for-loop.\n\n#here we are using the sum function on a \"logical if\" for example we are on cycle 5 then the average patient age is now 5+60 which is 65, then there are 4 rows (which all show up as true or false values) that are less than or equal to 65, taking the sum gives us an index of 4 which is the appropriate index to select\ndeathRisk &lt;- sapply(1:60,function(x){\n  \n  #calculate which index select based on the age group\n  inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n  \n  #select the gender columns\n  #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n  genderCol &lt;- ifelse(male ==1,3,4)\n  \n  return(yearlyTProbs[inds,genderCol])\n  \n})",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-3",
    "href": "Exercises/Ch3-Exercise-35.html#step-3",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.3 Step 3",
    "text": "2.3 Step 3\nCreate the Markov Model. We must specify a transition matrix as in Exercise 2.5 and then calculate the number of individuals in each state for 60 cycles. The change here from Exercise 2.5 is that the transition probabilities change depending on the cycle.\nLet the use the Figure shown at the beginning of the file. Let the first column be PrimaryTHR, the second column be Success of primary THR (SuccessP), the third column be Revision THR, the fourth column be Success of Revision (SuccessR), and the fifth column be Death. Thus we have a 5 state Markov model.\n\n# The matrix will follow this structure, shown in Figure 3.7:\n# \n#                     To State\n#                       PrimaryTHR SuccessP RevisionTHR SuccessR Death\n# From    PrimaryTHR\n# State   SuccessP\n#         RevisionTHR \n#         SuccessR\n#         Death\n\n\n#note now that our transition matrix is now time-dependent, that is, depending on the cycle, the transition probability will change. Therefore we must make a function that alters the transition matrix based on the cycle. Fill in the following transition matrix function with the appropriate transition probabilities. To get the t'th value of vector such as mr, we can use the [t] operator.\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR), 0, 0, omrPTHR,\n    0, 1-(rr[t]+mr[t]) , rr[t], 0, mr[t],\n    0, 0, 0, 1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0, rrr, 1-(rrr+mr[t]), mr[t],\n    0, 0, 0, 0, 1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n}\n\n#check manually that each row sums to 1 by performing some algebra.\n\n#we must now calculate the amount of individuals in each state for 60 cycles. Re use the function created in exercise 2.5 but modify it slightly for the new markov model including the extra states and  time-dependent transition probabilities.\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs #round because we are using full population units\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a 60 (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\n\n#create our initial vector of population starts, all start in thePrimaryTHR state.\niVec &lt;- c(1000,0,0,0,0)\n\n#calculate all states for all cycles.\npopulationStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR,omrRTHR,rr= revisionRisk, mr = deathRisk,rrr=rrr,t=60)\n\n#check that the row sums are equal to 1000\nrowSums(populationStates)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-4",
    "href": "Exercises/Ch3-Exercise-35.html#step-4",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.4 Step 4",
    "text": "2.4 Step 4\nNext, adapt the model for a new prosthesis. We may reuse the previous results while adding the treatment effect.\n\n#new revision risk adjusts the lambda value by a scalar -- the hazard ratio of NP1\n#use the $ operator to extract the appropriate hazard ratio\nrrNP1 &lt;- survModelSummary$hazard_ratio[5]\n\nrevisionRiskNP1 &lt;- tProbsHazard(t=60,lambda = lambda*rrNP1,gamma = gamma)\n\n#calculate the updated states by calculateYearlyProbs function we created earlier and filling in the appropriate arguments\npopulationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=revisionRiskNP1,mr=deathRisk,rrr,t=60)\n\n#check that the row sums are equal to 1000\nrowSums(populationStatesNP1)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-5",
    "href": "Exercises/Ch3-Exercise-35.html#step-5",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.5 Step 5",
    "text": "2.5 Step 5\nCalculate the costs for both the standard and NP1 models. Import the discount formula from exercise 2.5\n\n#this formula comes directly from the previous exercise\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n#calculate Life-Years using rowSums, ensure to exclude the last state of death by using the [,-i] operator\nlifeYearsStandard &lt;-rowSums(populationStates[,-5])\n\n#create the cost vector, assume that we are removing the last state of death. The length of the vector should only then be 4, the total of the remaining states\ncosts&lt;- c(0,0,cRevision,0)\n\n#add a parameter for the initial cost. We had 1000 initial patients\niCostStandard &lt;- cStandard*1000\n\n#calculate the total cost by using matrix multiplication on our population state sets\ntotalCosts &lt;- populationStates[,-5] %*% costs\n\n\n#update the costs to account for discounting over time. Call the discount formula and fill in the appropriate arguments\ndiscCostStandard &lt;- discountFormula(totalCosts,cDR,t = 60)\n\n#next we need to repeat the previous steps for utility of the treatment over time\n#create a utility vector for each state except death\nutility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n\n#calculate the utility over time and the adjusted discounted utility, this should be a similar process as the costs\ntotalQuality &lt;-  populationStates[,-5] %*% utility\nQALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t = 60)\n\n#calculate the total cost for all cycles/person, ensure to include the initial cost of the treatment\nSTDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\nSTDLYs &lt;- sum(lifeYearsStandard)/1000\nSTDQALYS &lt;- sum(QALYStandard)/1000\n\n\n\n#####repeat for the new prosthesis (NP1)######\n#all steps should be the same for the new, with updated costs and utilities\n\n#use rowsums to get the total life years\nlifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n\n#total and discounted costs\ntotalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costs\ndiscCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t = 60)\n\n\n#add the initial cost for NP1 via cNP1\niCostNP1 &lt;- cNP1*1000\n\n\n#Utility\ntotalQualityNP1 &lt;-  populationStatesNP1[,-5] %*% utility\nQALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t = 60)\n\n#calculate the total cost for all cycles/person, ensure to add the initial cost of the new implant\nNP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\nNP1LYs &lt;- sum(lifeYearsNP1)/1000\nNP1QALYS &lt;- sum(QALYNP1)/1000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-6",
    "href": "Exercises/Ch3-Exercise-35.html#step-6",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.6 Step 6",
    "text": "2.6 Step 6\nCalculate the ICER for the new prosthesis compared to standard care\n\n#calculate the difference in costs\ndiffCost &lt;- NP1cost-STDcost\n\n#difference in QALYs\ndiffQALY &lt;- NP1QALYS-STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 2198.487",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-1-calculate-the-transition-probabilities",
    "href": "Exercises/Ch3-Exercise-35.html#step-1-calculate-the-transition-probabilities",
    "title": "Exercise 3.5",
    "section": "Step 1: Calculate the transition probabilities",
    "text": "Step 1: Calculate the transition probabilities\nLets create a function to calculate the transition probabilities for a yearly cycle t. The formula is given in Section 3.5.2 Section 2 iii).\nAs we noted above, R is vectorized. That means we can input a vector as an argument and each element of the vector will be passed through.\nWe want all of t = 1,…,60 to be calculated so we can simply use 1:t which creates a vector 1,…,t\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n  \n}\n\nWe can use this function to calculate the revision risk or the time-dependent transition probability per year.\n\nrevisionRisk &lt;- tProbsHazard(60,lambda = lambda,gamma = gamma)",
    "crumbs": [
      "Introduction",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-2-using-life-tables-for-background-mortality",
    "href": "Exercises/Ch3-Exercise-35.html#step-2-using-life-tables-for-background-mortality",
    "title": "Exercise 3.5",
    "section": "Step 2: Using life-tables for background mortality",
    "text": "Step 2: Using life-tables for background mortality\nWe want to make sure we are accounting for background mortality in our model. First, we will add the death rates and yearly transition probabilities provided in the exercise.\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\nNote that by default this exercise uses female. Lets create the death risk by analyzing the cycle for those who are female and have an average age of 60 plus the cycle year due to all cause mortality\nTo do this we will us use a special function in R called the apply family. This function takes two arguments x and a function of x. This function is then applied to all elements of x. We can use this to extract the appropriate cell of the yearlyTProbs dataset for all 60 cycles. The apply function family is essentially a wrapper of a for-loop, that can be quickly written. If you prefer the equivalent code, it can be written as a for-loop.\nHere we are using the sum function on a “logical if”. For example we are on cycle 5 then the average patient age is now 5+60 which is 65, then there are 4 rows (which all show up as true or false values) that are less than or equal to 65, taking the sum gives us an index of 4 which is the appropriate index to select.\n\ndeathRisk &lt;- sapply(1:60,function(x){\n  \n  #calculate which index select based on the age group\n  inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n  \n  #select the gender columns\n  #if else takes 3 arguments, the first is a logic check, if true, it returns the second value, \n  #if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n  genderCol &lt;- ifelse(male ==1,3,4)\n  \n  return(yearlyTProbs[inds,genderCol])\n  \n})",
    "crumbs": [
      "Introduction",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-3-creating-the-markov-model",
    "href": "Exercises/Ch3-Exercise-35.html#step-3-creating-the-markov-model",
    "title": "Exercise 3.5",
    "section": "Step 3: Creating the Markov Model",
    "text": "Step 3: Creating the Markov Model\nTo create the Markov Model, we must specify a transition matrix as in Exercise 2.5 and then calculate the number of individuals in each state for 60 cycles. The change here from Exercise 2.5 is that the transition probabilities change depending on the cycle.\nLet’s use the Figure shown at the beginning of the file. Let the first column be PrimaryTHR, the second column be Success of primary THR (SuccessP), the third column be Revision THR, the fourth column be Success of Revision (SuccessR), and the fifth column be Death. Thus we have a 5 state Markov model.\n\n# The matrix will follow this structure, shown in Figure 3.7:\n# \n#                     To State\n#                       PrimaryTHR SuccessP RevisionTHR SuccessR Death\n# From    PrimaryTHR\n# State   SuccessP\n#         RevisionTHR \n#         SuccessR\n#         Death\n\nNote that our transition matrix is now time-dependent. That is, depending on the cycle, the transition probability will change. Therefore we must make a function that alters the transition matrix based on the cycle. We will fill in the transition matrix function with the appropriate transition probabilities. To get the t’th value of vector such as mr, we can use the [t] operator.\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n}\n\nCheck. Manually check that each row sums to 1 by performing some algebra.\nWe must now calculate the amount of individuals in each state for 60 cycles. We will re-use the function created in exercise 2.5 but modify it slightly for the new Markov model so that it includes the extra states and the time-dependent transition probabilities.\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs #round because we are using full population units\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\nJust like in 2.5, we will create our initial vector. Again, everyone in the population starts in the PrimaryTHR state.\n\niVec &lt;- c(1000,0,0,0,0)\n\nThen we will calculate all states for all 60 cycles\n\npopulationStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR,omrRTHR,rr= revisionRisk, mr = deathRisk,rrr=rrr,t=60)\n\nCheck. We will use rowSums to make sure that all rows total to 1000\n\nrowSums(populationStates)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Introduction",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-4-adapt-the-model-for-a-new-prosthesis",
    "href": "Exercises/Ch3-Exercise-35.html#step-4-adapt-the-model-for-a-new-prosthesis",
    "title": "Exercise 3.5",
    "section": "Step 4: Adapt the Model for a New Prosthesis",
    "text": "Step 4: Adapt the Model for a New Prosthesis\nTo adapt the model for a new prosthesis, we will re-use the previous results while adding the treatment effect.\nThe new revision risk adjusts the lambda value by a scalar – the hazard ratio of NP1\n\n#use the $ operator to extract the appropriate hazard ratio\nrrNP1 &lt;- survModelSummary$hazard_ratio[5]\n\nrevisionRiskNP1 &lt;- tProbsHazard(t=60,lambda = lambda*rrNP1,gamma = gamma)\n\nWe will calculate the updated states using the calculateYearlyProbs function we created earlier and filling in the appropriate arguments\n\npopulationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=revisionRiskNP1,mr=deathRisk,rrr,t=60)\n\nCheck. We will check that the row sums are equal to 1000\n\nrowSums(populationStatesNP1)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Introduction",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-5-caculate-the-costs",
    "href": "Exercises/Ch3-Exercise-35.html#step-5-caculate-the-costs",
    "title": "Exercise 3.5",
    "section": "Step 5: Caculate the Costs",
    "text": "Step 5: Caculate the Costs\nWe need to calculate the costs for both the standard and new prosthesis models. To do this, we will use the discount formula from exercise 2.5\n\n#this formula comes directly from the previous exercise\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n\nWe will go through the steps for the standard treatment first\nWe will calculate Life-Years using rowSums, being sure to exclude the last state of death by using the [,-i] operator\n\nlifeYearsStandard &lt;-rowSums(populationStates[,-5])\n\nNext, we create the cost vector. The length of the vector should only then be 4, the total of the states with costs in the model.(Death can have costs that you might want to integrate in other models. But in this model, there are no costs associated with death.)\n\ncosts&lt;- c(0,0,cRevision,0)\n\nWe need to add a parameter for the initial cost. Note that we started with 1000 patients.\n\niCostStandard &lt;- cStandard*1000\n\nWe will calculate the total cost by using matrix multiplication to multiple our cost vector costs by our states matrix populationStates. We will use discountFormula to account for discounting over time.\n\ntotalCosts &lt;- populationStates[,-5] %*% costs\n\n#update the costs to account for discounting over time\ndiscCostStandard &lt;- discountFormula(totalCosts,cDR,t = 60)\n\nNext we need to repeat the previous steps for utility of the treatment over time. Just like for costs, we start by creating a utility vector for all states except death which has a utility = 0\n\nutility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n\nWe will calculate the total utility over time using matrix multiplication and then we will calculate the discounted utility.\n\ntotalQuality &lt;-  populationStates[,-5] %*% utility\nQALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t = 60)\n\nLastly, we will calculate the total cost and utilities for all cycles/person, ensure to include the initial cost of the treatment\n\nSTDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\nSTDLYs &lt;- sum(lifeYearsStandard)/1000\nSTDQALYS &lt;- sum(QALYStandard)/1000\n\n\n\nRepeat for the new prosthesis (NP1)\nAll steps should be the same for the new prosthesis, with updated costs and utilities\n\n#use rowsums to get the total life years\nlifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n\n#total and discounted costs\ntotalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costs\ndiscCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t = 60)\n\n#add the initial cost for NP1 via cNP1\niCostNP1 &lt;- cNP1*1000\n\n#Utility\ntotalQualityNP1 &lt;-  populationStatesNP1[,-5] %*% utility\nQALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t = 60)\n\n#calculate the total cost for all cycles/person, ensure to add the initial cost of the new implant\nNP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\nNP1LYs &lt;- sum(lifeYearsNP1)/1000\nNP1QALYS &lt;- sum(QALYNP1)/1000",
    "crumbs": [
      "Introduction",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-6-calculate-the-icer",
    "href": "Exercises/Ch3-Exercise-35.html#step-6-calculate-the-icer",
    "title": "Exercise 3.5",
    "section": "Step 6: Calculate the ICER",
    "text": "Step 6: Calculate the ICER\nThe final step is to calculate the ICER for the new prosthesis compared to standard care\n\n#calculate the difference in costs\ndiffCost &lt;- NP1cost-STDcost\n\n#difference in QALYs\ndiffQALY &lt;- NP1QALYS-STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 2198.487",
    "crumbs": [
      "Introduction",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html",
    "href": "Exercises/Ch4-Exercise-47.html",
    "title": "\n1  Exercise 4.7\n",
    "section": "",
    "text": "1.1 Part 1: Drawing the log-normal distribution\nSome useful functions in R: log(x) by default calculates the natural logarithm of x. R has many built in functions to generate random numbers. For example, rnorm(n,mean,sd) generates n random numbers with mean and sd parameters.\nBecause random draws are taken from many distributions, the results of this exercise will vary for each user. To ensure reproducibility we set a seed which allows the random numbers generated to be the same for all those who use the same seed (provided the operating systems are the same).\nWe will start by setting the seed and adding in the provided parameters.\n#set a seed for reproducibility\nset.seed(123)\n\n##fixed parameters\nRR &lt;- 0.509\n\n#discount rate\ncDR &lt;- 0.06\n\n#the confidence interval\nCI_RR &lt;- c(0.365, 0.710)\n\n#drug costs, these are known and fixed\ncAZT &lt;- 2278 #cost of Zidovudine\ncLam &lt;- 2086.5 #cost of Lamivudine\nWe need to re-arrange the confidence interval formula to calculate the standard error.\nRemember that the normal distribution’s parameters are on the log scale. So, the confidence interval parameters and relative risk must be transformed accordingly.\nSE_RR &lt;- (log(CI_RR[2])-log(CI_RR[1]))/(2*1.96)\nCheck. We can check we’ve done it properly by using the formulas below, They should provide the same results as the formula above.\nexp(log(RR)-1.96*SE_RR)\n\n[1] 0.3649514\n\nexp(log(RR)+1.96*SE_RR)\n\n[1] 0.7099055\nNext, calculate the log mean and logRR; these are the parameters of the log-normal distribution.\nlnMeanRR &lt;- log(RR)\nlnSERR &lt;- SE_RR\nWe will now draw from the normal distribution.\nlnRRDraw &lt;- rnorm(1,mean = lnMeanRR,sd = lnSERR)\nRRSim &lt;- exp(lnRRDraw)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-2-using-the-distribution-to-draw-random-costs",
    "href": "Exercises/Ch4-Exercise-47.html#part-2-using-the-distribution-to-draw-random-costs",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.2 Part 2: Using the distribution to draw random costs",
    "text": "1.2 Part 2: Using the distribution to draw random costs\nWe may use the rgamma(m,shape,scale) function to draw random numbers from the gamma distribution. Recall the formulae from 4.4.3 for parameterizing the gamma distribution using the method of moments. Take care to ensure the parameterization of the gamma distribution matches that of 4.4.3. Use rgamma() to check the parameterization. By default the parameterization should be \\(\\beta\\) = scale.\nFor this exercise we will take the mean costs directly from exercise 2.5 and assume the mean costs for the care are equal to their standard errors.\nNote: In R we can nest the assignment operator &lt;- to save space\n\ndmca &lt;- SEdmca &lt;- 1701 #direct medical cost of A\ndmcb &lt;- SEdmcb &lt;- 1774 #direct medical cost of B\ndmcc &lt;- SEdmcc &lt;- 6948 #direct medical cost of C\nccca &lt;- SEccca &lt;- 1055 #community care cost of A\ncccb &lt;- SEcccb &lt;- 1278 #community care cost of B\ncccc &lt;- SEcccc &lt;- 2059 #community care cost of C\n\nTo simplify calculations, we will create a function that calculates the mean and sd of the gamma distribution based on the mean and standard deviation.\n\ngammaDistAlpha &lt;- function(mean,sd){\n  \n  return((mean^2)/(sd^2))\n  \n}\n\ngammaDistBeta &lt;- function(mean,sd){\n  \n  return((sd^2)/(mean))\n  \n}\n\nNow we will create random draws\n\ndmcaSim &lt;- rgamma(1, shape = gammaDistAlpha(dmca,SEdmca),scale = gammaDistBeta(dmca,SEdmca))\ndmcbSim &lt;- rgamma(1, shape = gammaDistAlpha(dmcb,SEdmcb),scale = gammaDistBeta(dmcb,SEdmcb))\ndmccSim &lt;- rgamma(1, shape = gammaDistAlpha(dmcc,SEdmcc),scale = gammaDistBeta(dmcc,SEdmcc))\n\ncccaSim &lt;- rgamma(1, shape = gammaDistAlpha(ccca,SEccca),scale = gammaDistBeta(ccca,SEccca))\ncccbSim &lt;- rgamma(1, shape = gammaDistAlpha(cccb,SEcccb),scale = gammaDistBeta(cccb,SEcccb))\nccccSim &lt;- rgamma(1, shape = gammaDistAlpha(cccc,SEcccc),scale = gammaDistBeta(cccc,SEcccc))",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-4",
    "href": "Exercises/Ch4-Exercise-47.html#part-4",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.3 Part 4",
    "text": "1.3 Part 4\nGenerating new transition probability matrices using the dirichlet distirbution\nRecall that the transition matrix in exercise 2.5 is given. The exercises in the excel file has the reader separate the matrix into dichotomous and non-dichotomous transition probabilities and generate random numbers using a beta distribution for the dichotomous events and dirichlet distribution for the non-dichotomous events. There is also no dirichlet distribution in Excel.\nInstead, in R, we can tackle this issue more easily. We quickly vectorize the random number generation to speed up calculations, and use the MCMCpack (Martin et al., 2011) to draw from the dirichlet distribution.\n\n#recall the transition matrix from the exercise 2.5\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\n\n#the equivalent alphas are given (note the deterministic value is alpha / (alpha + beta)), which is exactly the transition matrix given above. The betas are excluded here for simplicity\n\ntAlpha &lt;- matrix(\n  \n  c(1251, 350, 116  , 17 ,\n    0   , 731, 512  , 15 ,\n    0   , 0  , 1312 , 437, \n    0   , 0  , 0    , 1749 #note this alpha is not required as we know all are in the last state\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\n#lets use the apply function in R to quickly draw random numbers from the dirichlet distribution using the MCMC pack function and apply it to each row of tAlpha\nlibrary(MCMCpack)\n\nLoading required package: coda\n\n\nLoading required package: MASS\n\n\n##\n## Markov Chain Monte Carlo Package (MCMCpack)\n\n\n## Copyright (C) 2003-2025 Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park\n\n\n##\n## Support provided by the U.S. National Science Foundation\n\n\n## (Grants SES-0350646 and SES-0350613)\n##\n\n#note we only give n = 1 to the rdirichlet distribution as it generates a random vector of length length(alpha)\n\n#use \"1\" to specify to apply the function by rows\ntProbRand &lt;- t(apply(tAlpha,1,function(x){\n  \n  return(rdirichlet(1,x))\n}))\n\n#the rdirichlet function by default returns the vector of draws by columns, when we want these results by rows. To get the matrix back into our original form, we can just use the t() function to transpose matrix.\n\n#our new transition probability matrix\ntProbRand \n\n          [,1]      [,2]       [,3]        [,4]\n[1,] 0.7269368 0.2026091 0.05981664 0.010637517\n[2,] 0.0000000 0.5734102 0.41752856 0.009061196\n[3,] 0.0000000 0.0000000 0.75511187 0.244888130\n[4,] 0.0000000 0.0000000 0.00000000 1.000000000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-5",
    "href": "Exercises/Ch4-Exercise-47.html#part-5",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.4 Part 5",
    "text": "1.4 Part 5\nRe-running the Markov model from exercise 2.5\nReturning to create the model in 2.5. Now that we have defined all our parameters in this exercise by drawing from random distributions. Let us take the opportunity to merge all of exercise into one function so that we can call it easily. This function will take in the costs, number of years, transition matrices of the two models, and the discount rate, and then output the costs and life years of the two treatments.\n\n#ensure to list all the previously built functions over here\ncalculatetProbCombination &lt;- function(tProbs,RR){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n#identical functions\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #Loop through all time-points and multiply the vector by \n  for(i in 1:(t)){\n\n    matReturn[i,] &lt;-   iVec %*% tProbs\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a 20 (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\n#build the function here for exercise 2.5 \nanalysisFunc &lt;- function(dmca,dmcb,dmcc,ccca,cccb,cccc,RR,cAZT,cALam,cDR,tProbs,iVec,t){\n  \n  #monotherapycost\n  \n  #call the function\n  yearlyProbs &lt;- calculateYearlyProbs(tProbs,t,iVec)\n\n  #throw error if row sums are not equal to 1\n  #stopifnot(!rowsum(yearlyProbs)==1)\n  lifeYears &lt;- rowSums(yearlyProbs[,-4])\n  \n  costA &lt;- dmca+ccca+cAZT\n  costB &lt;- dmcb+cccb+cAZT\n  costC &lt;- dmcc+cccc+cAZT\n\n  costVector &lt;- c(costA,costB,costC)\n\n  #calculate the non-discounted cost\n  nonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\n  discCost &lt;- discountFormula(nonDiscCost, discRate = cDR,t)\n  #calculate the total costs and life years over the 20 years\n  totalDiscCostMonoTherapy &lt;- sum(discCost)\n  totalLifeYearsMonoTherapy &lt;- sum(lifeYears)\n  \n  #calculate the combination therapy\n  \n  tProbsComb &lt;- calculatetProbCombination(tProbs,RR = RR)\n  \n  #check to ensure all rows sum to 1\n  rowSums(tProbsComb)\n  \n  #calculate the yearly proportions (for the first two years)\n  probsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n  \n  #calculate rest of years\n  probsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = t-2,iVec =probsCombYearly1_2[2,])\n  \n  #combine them\n  probsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n  \n    \n  #calculate the life-years\n  lifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n  \n  #calculate the costs\n  costAComb &lt;- costA+cLam\n  costBComb &lt;- costB+cLam\n  costCComb &lt;- costC+cLam\n  #combine the costs into a vector\n  costVectorComb &lt;- c(costAComb,costBComb,costCComb)\n  \n  #hint: use matrix multiplication\n  costCombNonDisc1_2 &lt;-   probsCombYearly[1:2,-4] %*% costVectorComb\n  costCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n  \n  #hint use rbind to combine the non-discounted cost\n  costCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n  \n  #calculate the discounted rate\n  costCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,t)\n  \n  #calculate the total costs and life years for the combination therapy\n  totalLifeYearsComb &lt;- sum(lifeYearsComb)\n  totalDiscCostComb &lt;- sum(costCombDisc)\n  \n  #return a list of all the relevant values\n  \n  return(list(MonoLYs = totalLifeYearsMonoTherapy,MonoDiscCost = totalDiscCostMonoTherapy,CombLYs = totalLifeYearsComb , CombDiscCost = totalDiscCostComb))\n  \n}",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-6",
    "href": "Exercises/Ch4-Exercise-47.html#part-6",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.5 Part 6",
    "text": "1.5 Part 6\nCalculate the ICER using the function we created and the new random draws\n\n#specify the initial vector\niVec &lt;- c(1,0,0,0)\n\n#call\nresults &lt;- analysisFunc(dmca = dmcaSim,dmcb = dmcbSim,dmcc = dmccSim,ccca = cccaSim,cccb = cccaSim,cccc = ccccSim,RR = RRSim,cAZT = cAZT, cALam = cALam, cDR = cDR, tProbs = tProbRand,iVec = iVec,t = 20)\n\n\n#we can extract any element from the list by its name using the $ operator\nICER &lt;- (results$CombDiscCost-results$MonoDiscCost)/(results$CombLYs-results$MonoLYs)\nICER\n\n[1] 2720.033",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-3-generating-new-transition-probability-matrices-using-the-dirichlet-distirbution",
    "href": "Exercises/Ch4-Exercise-47.html#part-3-generating-new-transition-probability-matrices-using-the-dirichlet-distirbution",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.3 Part 3: Generating new transition probability matrices using the dirichlet distirbution",
    "text": "1.3 Part 3: Generating new transition probability matrices using the dirichlet distirbution\nRecall the transition matrix given in exercise 2.5. The exercise in the excel file has the reader separate the matrix into dichotomous and non-dichotomous transition probabilities and generate random numbers using a beta distribution for the dichotomous events and dirichlet distribution for the non-dichotomous events. There is also no dirichlet distribution in Excel.\nIn R we can tackle this issue more easily. We are able to quickly vectorize the random number generation to speed up calculations, and use the MCMCpack (Martin et al., 2011) to draw from the dirichlet distribution.\nBelow we load in the transition matrix provided in exercise 2.5\n\n#recall the transition matrix from the exercise 2.5\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\nThe equivalent alphas are given (note the deterministic value is alpha / (alpha + beta)), which is exactly the transition matrix given above. The betas are excluded here for simplicity\n\ntAlpha &lt;- matrix(\n  \n  c(1251, 350, 116  , 17 ,\n    0   , 731, 512  , 15 ,\n    0   , 0  , 1312 , 437, \n    0   , 0  , 0    , 1749 #note this alpha is not required as we know all are in the last state\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\nLets use the apply function to quickly draw random numbers from the dirichlet distribution using the function from MCMCpack and apply it to each row of tAlpha. First, we will need load the MCMCpack library. In order to do this, you will need to have it installed. You can install it using this code install.packages(\"MCMCpack\")\n\n#load library\nlibrary(MCMCpack)\n\nLoading required package: coda\n\n\nLoading required package: MASS\n\n\n##\n## Markov Chain Monte Carlo Package (MCMCpack)\n\n\n## Copyright (C) 2003-2025 Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park\n\n\n##\n## Support provided by the U.S. National Science Foundation\n\n\n## (Grants SES-0350646 and SES-0350613)\n##\n\n\nNote we only give n = 1 to the rdirichlet distribution as it generates a random vector of length(alpha).\nThe rdirichlet function by default returns the vector of draws by columns, but when we want these results by rows. To get the matrix back into our original form, we can just use the t() function to transpose matrix.\n\n#use \"1\" to specify to apply the function by rows\ntProbRand &lt;- t(apply(tAlpha,1,function(x){\n  \n  return(rdirichlet(1,x))\n}))\n\n#our new transition probability matrix\ntProbRand \n\n          [,1]      [,2]       [,3]        [,4]\n[1,] 0.7269368 0.2026091 0.05981664 0.010637517\n[2,] 0.0000000 0.5734102 0.41752856 0.009061196\n[3,] 0.0000000 0.0000000 0.75511187 0.244888130\n[4,] 0.0000000 0.0000000 0.00000000 1.000000000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-4-re-running-the-markov-model-from-exercise-2.5",
    "href": "Exercises/Ch4-Exercise-47.html#part-4-re-running-the-markov-model-from-exercise-2.5",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.4 Part 4: Re-running the Markov model from exercise 2.5",
    "text": "1.4 Part 4: Re-running the Markov model from exercise 2.5\nNow that we have defined all our parameters in this exercise by drawing from random distributions where appropriate. Let us take the opportunity to merge all of the exercise into one function so that we can call it easily. This function will take in the costs, number of years, transition matrices of the two models, and the discount rate, and then output the costs and life years for each of the two treatments.\nTo begin, we will load in all of our previously built functions.\n\n#ensure to list all the previously built functions over here\ncalculatetProbCombination &lt;- function(tProbs,RR){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n#identical functions\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #Loop through all time-points and multiply the vector by \n  for(i in 1:(t)){\n\n    matReturn[i,] &lt;-   iVec %*% tProbs\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a t (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\nThen we will use these functions to create a single analysis function. We can build in an error check to make sure our rows sum to 1 as before.\n\nanalysisFunc &lt;- function(dmca,dmcb,dmcc,ccca,cccb,cccc,RR,cAZT,cALam,cDR,tProbs,iVec,t){\n  \n  #monotherapycost\n  \n  #call the function\n  yearlyProbs &lt;- calculateYearlyProbs(tProbs,t,iVec)\n\n  #throw error if row sums are not equal to 1\n  #stopifnot(!rowsum(yearlyProbs)==1)\n  \n  lifeYears &lt;- rowSums(yearlyProbs[,-4])\n  \n  costA &lt;- dmca+ccca+cAZT\n  costB &lt;- dmcb+cccb+cAZT\n  costC &lt;- dmcc+cccc+cAZT\n\n  costVector &lt;- c(costA,costB,costC)\n\n  #calculate the non-discounted cost\n  nonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\n  discCost &lt;- discountFormula(nonDiscCost, discRate = cDR,t)\n  #calculate the total costs and life years over the 20 years\n  totalDiscCostMonoTherapy &lt;- sum(discCost)\n  totalLifeYearsMonoTherapy &lt;- sum(lifeYears)\n  \n  #calculate the combination therapy\n  \n  tProbsComb &lt;- calculatetProbCombination(tProbs,RR = RR)\n  \n  #check to ensure all rows sum to 1\n  rowSums(tProbsComb)\n  \n  #calculate the yearly proportions (for the first two years)\n  probsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n  \n  #calculate rest of years\n  probsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = t-2,iVec =probsCombYearly1_2[2,])\n  \n  #combine them\n  probsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n  \n  #calculate the life-years\n  lifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n  \n  #calculate the costs\n  costAComb &lt;- costA+cLam\n  costBComb &lt;- costB+cLam\n  costCComb &lt;- costC+cLam\n  \n  #combine the costs into a vector\n  costVectorComb &lt;- c(costAComb,costBComb,costCComb)\n  \n  #use matrix multiplication to calculate yearly costs\n  costCombNonDisc1_2 &lt;-   probsCombYearly[1:2,-4] %*% costVectorComb\n  costCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n  \n  #use rbind to combine the non-discounted cost\n  costCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n  \n  #calculate the discounted costs\n  costCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,t)\n  \n  #calculate the total costs and life years for the combination therapy\n  totalLifeYearsComb &lt;- sum(lifeYearsComb)\n  totalDiscCostComb &lt;- sum(costCombDisc)\n  \n  #return a list of all the relevant values\n  return(list(MonoLYs = totalLifeYearsMonoTherapy,MonoDiscCost = totalDiscCostMonoTherapy,CombLYs = totalLifeYearsComb , CombDiscCost = totalDiscCostComb))\n  \n}",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-5-calculating-the-icer",
    "href": "Exercises/Ch4-Exercise-47.html#part-5-calculating-the-icer",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.5 Part 5: Calculating the ICER",
    "text": "1.5 Part 5: Calculating the ICER\nJust as in exercise 2.5, our last step is to calculate the ICER. We will use the function we created and the new random draws.\n\n#specify the initial vector\niVec &lt;- c(1,0,0,0)\n\n#call our new analysis function\nresults &lt;- analysisFunc(dmca = dmcaSim,dmcb = dmcbSim,dmcc = dmccSim,ccca = cccaSim,cccb = cccaSim,cccc = ccccSim,RR = RRSim,cAZT = cAZT, cALam = cALam, cDR = cDR, tProbs = tProbRand,iVec = iVec,t = 20)\n\nWe can extract any element from the list by its name using the $ operator\n\nICER &lt;- (results$CombDiscCost-results$MonoDiscCost)/(results$CombLYs-results$MonoLYs)\nICER\n\n[1] 2720.033",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  }
]