# Exercise 5.7 {.unnumbered}

This section reproduces exercise 5.7 in R from Chapter 5 in the book "Decision Modelling for Health Economic Evaluation" by Andrew Briggs, Mark Sculpher, and Karl Claxton

In this exercise we are going to extend the probabilistic parameter generation from exercise 4.8 by using simulations to account for the combined uncertainty of the parameters. As R is a language specifically for statistical computing, it is not surprising that statistical simulations are frequently run in R. These simulations can be constructed using a variety of core R functions. In this exercise, we will use either for-loops directly or call wrappers such as `lapply`,
`apply`, or `sapply`.

Let's revisit exercise 4.8 by creating a few more functions that: 

1. Automatically generate all necessary parameters from the corresponding distribution 
2. Apply the parameters to yield the results

First we copy the analysis function from 4.8 and create another function that generates parameters.

## Part 1: Setting-up the analysis

We start by initializing all fixed parameters, bring over all the functions from the previous exercises. We also load the MASS package required to sample random numbers from the multivariate normal distribution.

```{r 5.7.1 Simulation functions}
library(MASS)

cStandard <- 394 #cost of standard implant
cNP1 <- 579 #cost of new implant

cDR <- 0.06 #cost discount rate
oDR <- 0.015 #outcome discount rate
age <- 60 #average age of all patients at receipt of primary implant
male <- 0 #sex indicator (0 for female, 1 for male)

iVec <- c(1000,0,0,0,0) #starting vector; everyone starts in the first state
t <- 60 #number of cycles

covMat <- matrix(
  c(0.0022515  , -0.005691 , 0.000000028, 0.0000051, 0.000259,
   -0.005691   ,  0.0432191,-0.000783   ,-0.007247 ,-0.000642,
    0.000000028, -0.000783 , 2.716e-05  , 0.000033 ,-0.000111,
    0.0000051  , -0.007247 , 0.000033   , 0.0118954, 0.000184,
    0.000259   , -0.000642 ,-0.000111   , 0.000184 , 0.1463686),
  nrow = 5, ncol = 5, byrow = T
)

colnames(covMat) <- rownames(covMat) <- c("lngamma","cons","age","male","NP1")

survModelSummary <- data.frame(
  variable = c("lngamma","cons","age","male","NP1"),
  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),
  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)
)
survModelSummary$hazard_ratio <- exp(survModelSummary$coefficient)




drawBetaMethodMoments <- function(n,mu,s){
  
  #functions estimates alpha and beta using the method of moments then draws from the beta distribution
  alpha <- ((mu*(1-mu)/s^2) -1)*mu
  beta <- alpha*(1-mu )/mu
  
  #draw our random number
  draw <- rbeta(n,alpha,beta)
  
  return(draw)
  
}


tProbsHazard <- function(t,lambda,gamma){
   
  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))
   
}


tProbs_time <- function(omrPTHR,omrRTHR,rr,mr,rrr,t){
  #omrPTHR is operative mortality rate following primary THR
  #omrRTHR is operative mortality rate following revision THR
  #rrr is re-revision risk
  #mr is mortality risk
  
  tProbs <- matrix(
  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,
    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],
    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],
    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],
    0, 0,               0,     0,                   1
  ),ncol = 5, nrow = 5, byrow = T
)
  
  return(tProbs)
  
}

#provided death rates and yearly transition probabilities
deathRates <- data.frame(
  Age = c("35-44","45-54","55-64","65-74","75-84","85 and over"),
  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),
  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)
  
)
yearlyTProbs <- data.frame(
    Age = c("35-44","45-54","55-64","65-74","75-84","85 and over"),
    Index = c(35,45,55,65,75,85),
    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),
    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)
)


discountFormula <- function(nonDiscount,discRate,t){
  
  return(nonDiscount/(1+discRate)^(1:t))
  
}



calculateYearlyProbs <- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){
  
  #create empty matrix that we will fill in
  
  matReturn <- matrix(nrow = t, ncol = 5)
  
  #initialize first vector of proportions
  
  #create column names
  colnames(matReturn) <- c("PrimaryTHR","SuccessP","RevisionTHR","SucessR","Death")

  for(i in 1:t){
    
    #get the corresponding transition matrix based on the time
    tProbs <- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)
    
    matReturn[i,] <- iVec %*% tProbs 
    
    #update ivec
    iVec <- iVec %*% tProbs
    
  }
  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t
  return(matReturn)
  
}


#complete primary analysis function for NP1
analysisNP1 <- function(omrPTHR,omrRTHR,mr,rrr,rrNP1,cPrimary,cRevision,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){

  #calculate the revision risk
  rr <- tProbsHazard(t=t,lambda = lambda,gamma = gamma)
  mr <- sapply(1:t,function(x){
    
    #calculate which index select based on the age group
    inds <- sum(x+age >= yearlyTProbs$Index)
    
    #select the gender columns
    #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.
    genderCol <- ifelse(male ==1,3,4)
    
    return(yearlyTProbs[inds,genderCol])
    
  })
    
  #calculate standard states
  standPopStates <- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)
  lifeYearsStandard <- rowSums(standPopStates[,-5])
  #excludes death year
  costVec <- c(0,0,cRevision,0)

  #add a parameter for the initial cost we had 1000 initial patients
  iCostStandard <- cStandard*1000
  
  #first calculate the total cost
  totalCosts <- standPopStates[,-5] %*% costVec
  
  #calculate the discounted cost
  discCostStandard <- discountFormula(totalCosts,cDR,t=t)
  
  #calculate the quality adjusted life years by creating a vector for each state utility except death
  utility<- c(0,uSuccessP,uRevision,uSuccessR)
  
  #multiply by the cohort
  totalQuality <- standPopStates[,-5] %*% utility
  QALYStandard <- discountFormula(totalQuality,discRate = oDR,t=t)
  
  #calculate the total cost for all cycles/person
  STDcost <- sum(c(iCostStandard,discCostStandard))/1000
  STDLYs <- sum(lifeYearsStandard)/1000
  STDQALYS <- sum(QALYStandard)/1000

  
  ###repeat this for the NP1###
  rrNP1_vec <- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)

  #call the previous function created
  populationStatesNP1 <- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)
  
  #calculate life years for np1
  lifeYearsNP1 <- rowSums(populationStatesNP1[,-5])
  
  #total and discounted costs
  totalCostsNP1 <- populationStatesNP1[,-5] %*% costVec
  discCostsNP1 <- discountFormula(totalCostsNP1,cDR,t=t)
  #add the initial cost for NP1
  iCostNP1 <- cNP1*1000
  #Utility
  totalQualityNP1 <- populationStatesNP1[,-5] %*% utility
  QALYNP1 <- discountFormula(totalQualityNP1,discRate = oDR,t=t)
  
  #calculate the total cost for all cycles/person
  NP1cost <- sum(c(iCostNP1,discCostsNP1))/1000
  NP1LYs <- sum(lifeYearsNP1)/1000
  NP1QALYS <- sum(QALYNP1)/1000
  
  #returns a list of discounted cost and QALYs for each method
  return(list(STDcost = STDcost, STDQALYS = STDQALYS, NP1cost = NP1cost,NP1QALYS = NP1QALYS, ICER = (NP1cost-STDcost)/(NP1QALYS-STDQALYS)))
  
}
```

### Now we will create our simulation function.

We start by initializing a dataframe to store our results, then iterating through each parameter and running our analysis function. This could be created using `lapply`, however it is probably easier to view the logic by using a for-loop.

This simulation function will encapsulate all statistics (functions of the data) or almost all values necessary to calculate the cost-effectiveness. However, due to R's vectorization, and the fact that the cost effectiveness metrics are functions of other columns. We could alternatively calculate many of the metrics after the simulation is completed using R's vectorization.

In the following Code: 

* **NMB** refers to "Net Monetary Benefit" 
* **CE** refers to "Cost effective"

Create our simulation function here:

```{r 5.7.1 simulation function}
generateSimulations <- function(nReps = 1000,age=60,male=0,cRatio = 100000){
   
   #we need to know how many columns or variable we have here in ncol
   cols <- c("omrPTHR","omrRTHR","rrNP1","rrr","lambda","gamma",
             "cPrimary","cRevision","cSuccess","uSuccessP","uSuccessR",
             "uRevision","cRatio","STDCost","STDQALYS","NP1Cost","NP1QALYS",
             "STDNMB","NP1NMB","NP1Inc","CESTD","CENP1","CENP1Inc")
   
   dfReturn <- data.frame(matrix(NA,nrow = nReps,ncol = length(cols)))
  
   #fill out the column names for our dataframe
   colnames(dfReturn) <- cols

   #cRatio is fixed at 100000
   #This is the threshold ratio
   dfReturn$cRatio <- cRatio
   alpha <- (5294/1487)^2
   beta <- 1487^2 / 5294
   
   #due to R's vectorization, we can sample all the parameters at once in the "n" parameter
   omrPTHR <- rbeta(nReps,2,98) #operative mortality rate following primary THR
   omrRTHR <- rbeta(nReps,2,98) #operative mortality rate following revision THR
   rrr <- rbeta(nReps,4,96) #re-revision risk
   
   #save them here using R's vectorization
   dfReturn$omrPTHR <- omrPTHR
   dfReturn$omrRTHR <- omrRTHR 
   dfReturn$rrr <- rrr
   
   #cost and utility
   cRevision <- rgamma(nReps,shape = alpha,scale = beta)
   uSuccessP <- drawBetaMethodMoments(nReps,0.85,0.03)
   uSuccessR <- drawBetaMethodMoments(nReps,0.75,0.04)
   uRevision <- drawBetaMethodMoments(nReps,0.3,0.03)
   
   dfReturn$cRevision <- cRevision
   dfReturn$uSuccessP <- uSuccessP
   dfReturn$uSuccessR <- uSuccessR
   dfReturn$uRevision <- uRevision 
   
   #draw from multivariate normal
   normDraw <- MASS::mvrnorm(nReps, mu = survModelSummary$coefficient,Sigma = covMat)
   
   #using R's vectorization, we can calculate operations on the entire vector, we must use [,"name"]as normDraw is not a matrix rather than a vector
   lambda <- exp(normDraw[,'cons'] + normDraw[,'age']*age + normDraw[,'male']*male)
   gamma <- exp(normDraw[,'lngamma'])
   rrNP1 <- exp(normDraw[,'NP1'])
   
   dfReturn$lambda <- lambda
   dfReturn$gamma <- gamma
   dfReturn$rrNP1 <- rrNP1

  #start the for-loop
  
  for(i in 1:nReps){
    
    #call the analysis function and specify the iteration for the parameter to be selected
    #those with a parameter that is constant do not need to be called from dfReturn
    results <- analysisNP1(dfReturn$omrPTHR[i],dfReturn$omrRTHR[i],mr,dfReturn$rrr[i],dfReturn$rrNP1[i],
                           dfReturn$cPrimary[i],dfReturn$cRevision[i],dfReturn$cStandard[i],dfReturn$uSuccessP[i],
                           dfReturn$uSuccessR[i],dfReturn$uRevision[i],cDR,oDR,cNP1,dfReturn$gamma[i],dfReturn$lambda[i],iVec,t)
    
    #save the results
    dfReturn$STDCost[i] <- results$STDcost
    dfReturn$STDQALYS[i] <- results$STDQALYS
    dfReturn$NP1Cost[i] <- results$NP1cost
    dfReturn$NP1QALYS[i] <- results$NP1QALYS
    
    #calculate net monetary benefit
    dfReturn$STDNMB[i] <- results$STDQALYS*dfReturn$cRatio[i]-results$STDcost
    dfReturn$NP1NMB[i] <- results$NP1QALYS*dfReturn$cRatio[i]-results$NP1cost
    dfReturn$NP1Inc[i] <- (results$NP1QALYS-results$STDQALYS)*dfReturn$cRatio[i] - (results$NP1cost-results$STDcost)
    
    #calculate the cost effectiveness
    dfReturn$CESTD[i] <- ifelse(dfReturn$STDNMB[i]>= dfReturn$NP1NMB[i],1,0)
    dfReturn$CENP1[i] <- ifelse(dfReturn$CESTD[i]==1,0,1)
    dfReturn$CENP1Inc[i] <- ifelse(dfReturn$NP1Inc[i]>0,1,0)
    
    #the above formulae come directly from the textbook 5.1.4
  }
   
  return(dfReturn)
   
}
```

## Part 2: Calling our simulation function & plotting our cost-effectiveness plane

In this section we will be using `ggplot2` to plot our results. `ggplot2` is
generally the plotting package of choice in R and has it own unique
syntax.  If you don't have `ggplot2` installed, you can install it using `install.packages("ggplot2")`

:::{.callout-tip}
We suggest briefly reviewing
<https://ggplot2.tidyverse.org/articles/ggplot2.html> to get a sense of
how `ggplot2` works. We will provide the syntax here.
:::

We will begin by loading the `ggplot2` library and setting our starting seed.
```{r 5.7.2 load library & set seed}
library(ggplot2)

set.seed(1)
```

We can call the simulation by specifying any number of repetitions after the `nReps =` argument

```{r 5.7.2 set number of reps}
res <- generateSimulations(nReps = 1000)
```

Now we will quickly create the difference in costs and difference in QALYs for each intervention. 

Because we have access to all columns we can quickly perform vector operations on them.
```{r 5.7.2 calculate differences in costs and QALYs}
res$diffCost <- res$NP1Cost-res$STDCost
res$diffQALYs <- res$NP1QALYS-res$STDQALYS
```

We will use these calculations to create a plot using `ggplot2`

The syntax takes a bit of getting used to but the plots are generally quite pretty.
```{r 5.7.2 create plot}
ggplot(res,
       aes(
         x = diffQALYs,
         y = diffCost)) + 
      geom_point(
        colour = "#414487") + 
      theme_minimal() + 
      labs(
        x = "QALYs", 
        y = "Cost", 
        title = "Increase in cost effectiveness plane")
```

## Part 3: Adding a threshold

Let's analyse the proportion of our simulation based on the threshold ratio that we specified earlier of $100,000/QALY. 

Let's also consider changing the threshold value by looping through various possibilities.

```{r 5.7.3 proportion of cost effectiveness cRatio 100,000}
#mean proportion of STD cost effective
mean(res$CESTD)

#mean proportion of NP1 cost effective
mean(res$CENP1)

#equivalently, the same NP1 net monetary benefit as the "increase" over the standard
mean(res$CENP1Inc)
```

The NP1 implant is chosen over the standard implant 99.9% of the time with a cost threshold of $100,000/QALY.

What if instead we want to see what happens if we plot this threshold value from 0 to 100,000?
We can estimate this numerically by running our simulation many times for different values of cRatio and plotting the results
```{r 5.7.3 cRatio 0 to 100000}
cRatios <- seq(0, 100000, by = 2500)
```

To loop through the cRatios and calculate the proportion of cost effectiveness we can write another for-loop or...
instead since cRatios is a vector, we can use `sapply` to quickly loop through the vector and calculate the proportion output from the `resultsNP1()` function.

```{r 5.7.3 cRatio sapply and resultsNP1() function}
cRatioResults <- sapply(cRatios,function(x){
  
  #call the simulation
  NP1sim <- generateSimulations(nReps = 1000,cRatio = x)
  
  #calculate the proportion for each simulatiom
  propNP1CE <- mean(NP1sim$CENP1)
  
  return(propNP1CE)
  
})

ncRatios <- length(cRatios)
dfcRatios <- data.frame(cRatio = cRatios,probCENP1 = cRatioResults,probCESTD = 1-cRatioResults)
```

Now we can plot our results using `ggplot2`.
```{r 5.7.3 plot results with varying cRatios}
ggplot(dfcRatios,
       aes(
         x = cRatio,
         y = probCENP1)) + 
      geom_line(
        colour = '#414487',
        linewidth = 1.2) + 
      theme_minimal()+ 
      labs(
        x = "Value of ceiling ratio", 
        y = "Proportion of cost-effective of NP1 treatment", 
        title = "Proportion of cost effective by value of ceiling ratio",
        colour = "Treatment") 
```

## Part 4: Examining subgroups

Up to this point, we have only been looking at one age category and one gender. Let's now build a function that loops through all possible combinations of age and gender and evaluate the proportion of cost-effectiveness treatment of NP1. 

Instead of using the convenient `sapply()` as in the previous part, we will use a for-loop to explicitly show which intersection of the subgroup is being analyzed.

We'll start by specifying our subgroups of interest
```{r 5.7.4 subgroup analyses 1}
ages <- c(40,60,80)
gender <- c(0,1)
```

Now, all possible combinations of these values can be easily calculated using `expand.grid`, note we also want all possible ceiling ratios (cRatios).
```{r 5.7.4 subgroup analyses 2}
factorsOfInterest <- expand.grid(cRatio = cRatios, age=ages, male = gender)
```

We want to add the column that we will hold our results
```{r 5.7.4 subgroup analyses 3}
factorsOfInterest$propNP1CE <- NA
```

We will then loop through the grid and perform the simulation on each row. Below we specify our function,
```{r 5.7.4 subgroup analyses 4}
subGroupSimulation <- function(nReps,factorsOfInterest){
   
  #calculate the number of combinations
  nCombinations <- nrow(factorsOfInterest)
  
  for(c in 1:nCombinations){
  
  #our current combination of the loop (current row)
  currentCombination <- factorsOfInterest[c,]
  
  #call our simulation function
  NP1sim <- generateSimulations(nReps = nReps, cRatio = currentCombination$cRatio ,age = currentCombination$age, male = currentCombination$male)
  
  #calculate the proportion of cost effectiveness
  propNP1CE <- mean(NP1sim$CENP1)
  
  #fill in the dataframe with the proportion
  factorsOfInterest$propNP1CE[c] <- propNP1CE
  }
  
  return(factorsOfInterest)
  
}
```

Now we'll use our function to calculate our results
```{r 5.7.4 subgroup analyses 5}
subGroupResults <- subGroupSimulation(1000,factorsOfInterest)
```

To make plotting easier, we will combine the age and gender columns so that they are in one variable
```{r 5.7.4 combine columns}
subGroupResults$combined_factor <- interaction(as.factor(subGroupResults$age),as.factor(subGroupResults$male),sep = "_")
```

We will again plot the results using `ggplot2`. This time, we manually change the names of the subgroups to provide appropriate labels in our graph. 

:::{.callout-tip}
You can specify colours for your graph by writing the colour names directly (e.g., "blue") or by entering hex codes as we have here. In this example, we've used 6 colours from the viridis colour palette because it is an accessible color palette and renders well in grey scale. <https://search.r-project.org/CRAN/refmans/viridisLite/html/viridis.html>
:::
```{r 5.7.4 plotting subgroup analysis results}
ggplot(subGroupResults,
       aes(
         x = cRatio,
         y = propNP1CE,
         colour = combined_factor)) + 
      geom_line(
        linewidth = 1.2,
        alpha = 0.8) + 
      labs(
        x = "Threshold Ratio", 
        y = "Proportion of NP1 cost effective", 
        title = "Line plot of cost effectiveness of NP1 implant by age and gender", 
        colour = 'Factor') +
      scale_color_manual(
        labels = c("40_0"="Female Age 40","60_0"= "Female Age 60","80_0"="Female Age 80", "40_1"="Male Age 40","60_1"= "Male Age 60","80_1"="Male Age 80"),
        values = c("40_0" = "#fde725","60_0" = "#7ad151","80_0" = "#22a884", "40_1" = "#2a788e", "60_1" = "#414487","80_1" = "#440154"))
```
