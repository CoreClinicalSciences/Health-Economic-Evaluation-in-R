[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Guide to Health Economic Evaluation in R",
    "section": "",
    "text": "Introduction\nWelcome to this online guidebook on health economic evaluation in R. This is a living resource, designed to grow and evolve over time as new examples, exercises, and methods are added. Our goal is to support learners, researchers, and practitioners in developing the skills needed to build and analyze health economic models directly in R.\nBy working in R rather than in spreadsheets alone, analysts can take advantage of a flexible, script-based environment that enhances the transparency, reproducibility, and robustness of health economic evaluation. The guide introduces key concepts step by step, with practical exercises translated from standard texts and supplemented with modern R workflows.\nThroughout, we draw on widely used packages such as dplyr and tidyr for data manipulation, ggplot2 for visualization, and tools such as MASS and MCMCpack for probability distributions and simulation. Together, these exercises and examples aim to build both technical fluency in R and a deeper understanding of best practices in health economic modelling.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#coding-style-and-good-practices",
    "href": "index.html#coding-style-and-good-practices",
    "title": "Guide to Health Economic Evaluation in R",
    "section": "Coding style and good practices",
    "text": "Coding style and good practices\nGood coding style is an important part of reproducible research. While individual preferences may vary, there are core elements of good practice that make code easier to read, share, and maintain. These include:\n\nUsing human-readable names for variables and functions\n\nWriting comprehensive annotations and comments\n\nBreaking code into modular, reusable functions\n\nMaintaining consistent formatting and indentation\n\nKeeping scripts organized and well-structured\n\nIn this guidebook, we use the the Biopharmaceutical Software Working Group’s R Style Guide.\nFor those just getting started with R, we recommend the tidyverse style guide as a helpful reference.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Source/General-Guide/Ch0-Preamble-Matrix-Multiplication.html",
    "href": "Source/General-Guide/Ch0-Preamble-Matrix-Multiplication.html",
    "title": "Preamble on R and matrix operations",
    "section": "",
    "text": "Vectorization\nThis section briefly reviews common operations in R that will help make speed up the process of building writing code and markov models.\nOne feature that makes R stand out is its built-in vectorization ability. All basic operations such as addition, subtraction, multiplication, division, exponentiation, etc all are vectorized. This means that inputting a vector to these operators outputs a vector where the function has been applied to each of the elements of the vector simultaneously.\nTo initialize integer vector we can use the : operator, where it acts as from : to where from and to are integers (inclusive).",
    "crumbs": [
      "Preamble on R",
      "Preamble on R and matrix operations"
    ]
  },
  {
    "objectID": "Source/General-Guide/Ch0-Preamble-Matrix-Multiplication.html#vectorization",
    "href": "Source/General-Guide/Ch0-Preamble-Matrix-Multiplication.html#vectorization",
    "title": "Preamble on R and matrix operations",
    "section": "",
    "text": "Example\n\nvec &lt;- 1:10\n\nvec\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nNow we can try some vectorized operators.\n\nsqrt(vec)\n\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n\n\nor multiple operators at once\n\nvec + 2*sin(vec)\n\n [1] 2.682942 3.818595 3.282240 2.486395 3.082151 5.441169 8.313973 9.978716\n [9] 9.824237 8.911958\n\n\nTo access elements of a vector we can use the [i] operator, where i is the index of the element we want.\n\n#create our new vector, note by default, the \"-2\" acts on all elements of the vector\nnewVec &lt;- vec + 2*sin(vec) - exp(vec) - 2\n\n#accessing elements\nnewVec[1]\n\n[1] -2.03534\n\nnewVec[5]\n\n[1] -147.331",
    "crumbs": [
      "Preamble on R",
      "Preamble on R and matrix operations"
    ]
  },
  {
    "objectID": "Source/General-Guide/Ch0-Preamble-Matrix-Multiplication.html#matrix-operations",
    "href": "Source/General-Guide/Ch0-Preamble-Matrix-Multiplication.html#matrix-operations",
    "title": "Preamble on R and matrix operations",
    "section": "Matrix Operations",
    "text": "Matrix Operations\nWhen building markov models and building transition matrices, using matrix-vector multiplications simplifies manual computation significantly.\nTo multiply a matrix by a vector we must have the same number of columns in the matrix as rows in a vector. Consider below an example of a two-state markov model and the goal is to discern the proportion left in the first state after two time cycles. We also show how to select rows and columns of a matrix.\n\nMatrix multiplication example\nFirst, we will create our vector called iVec_example. The number of entries in this vector should be the same as the number of states. In this example we will assume that everyone starts in the first state.\nNote: the c() operation initializes a vector where we can input the values (it is considered by default a column vector)\n\niVec_example &lt;- c(1,0)\n\n\nBelow, we consider a two-state markov model. We build a 2 x 2 matrix of the transition probabilities:\n\ntProbs_example &lt;- matrix(c(0.7,0.3,\n                           0.1,0.9),\n                 nrow = 2, ncol = 2,\n                 byrow = T)\n\n\nNow, we want to calculate the proportion of individuals in the first time-cycle. The results will be saved in time1Prop\n\n\n\n\n\n\nNote\n\n\n\nNote: the number of columns in the matrix must match the number of rows in the vector.\n\n\n\ntime1Prop &lt;- tProbs_example %*% iVec_example\n\n\nTo get the proportion after the second-time we can multiply the first-time proportion that we just calculated by the transition probability matrix\n\ntime2Prop &lt;- tProbs_example %*% time1Prop\n\n\nWe can use the [i,j] operator to extract row i and column j of a matrix. This is the same as in the vector example with the addition of the comma, to seperate the columns and rows.\n\ntProbs_example[1,] #extracts the first row\n\n[1] 0.7 0.3\n\ntProbs_example[,2] #extracts the second column\n\n[1] 0.3 0.9\n\ntProbs_example[1,2] #extracts first row and second column entry\n\n[1] 0.3\n\n\n\nWe can also use the -i operator to extract all except i\n\ntProbs_example[-1,]  #extracts all but the 1st first row\n\n[1] 0.1 0.9\n\ntProbs_example[,-1]  #extracts all but the 1st column\n\n[1] 0.3 0.9",
    "crumbs": [
      "Preamble on R",
      "Preamble on R and matrix operations"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/1-Decision-Modelling-For-HE-Evaluation.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/1-Decision-Modelling-For-HE-Evaluation.html",
    "title": "Book: Decision Modelling for Health Economic Evaluation",
    "section": "",
    "text": "Overview of Exercises\nThis section of the guide presents the exercises from Decision Modelling for Health Economic Evaluation by Andrew Briggs, Mark Sculpher, and Karl Claxton. We have translated these tasks from their original Excel format into R, providing an opportunity to practice decision modelling using a reproducible, script-based approach.\nThe original book is a key reference for decision modelling in health economics. While the official supporting materials are provided in other formats\n(available here), our contribution is to:\nThrough these exercises, learners develop skills in writing functions, performing matrix operations, running simulations, and incorporating parameter uncertainty via probability distributions and probabilistic sensitivity analysis. The exercises also introduce widely used R packages:\nBy combining these tools, the exercises strengthen both programming fluency and applied expertise in constructing, analyzing, and interpreting health economic decision models.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/1-Decision-Modelling-For-HE-Evaluation.html#overview-of-exercises",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/1-Decision-Modelling-For-HE-Evaluation.html#overview-of-exercises",
    "title": "Book: Decision Modelling for Health Economic Evaluation",
    "section": "",
    "text": "MASS and MCMCpack for probability distributions and simulation, alongside base R functions\ndplyr and tidyr for data manipulation\nggplot2 for creating visualizations such as cost-effectiveness planes\nscales and viridis for visualization formatting",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html",
    "title": "Overview of exercises",
    "section": "",
    "text": "Exercise 2.5 - A Simple Markov Model for Two HIV Treatments\nThis exercise reviews how to run a basic Markov model that compares the cost effectiveness of two HIV treatments. The first treatment involves a monotherapy of Zidovudine (control), against a combination therapy of Zidovudine and Lamivudine (treatment). The combination therapy is only used in the first two years.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-2.5---a-simple-markov-model-for-two-hiv-treatments",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-2.5---a-simple-markov-model-for-two-hiv-treatments",
    "title": "Overview of exercises",
    "section": "",
    "text": "Steps\n\nWork out the transition probabilities between health states for the monotherapy group (control).\n\nUse these probabilities to run a Markov trace and follow the cohort through 20 years.\n\nCalculate the total costs for the control group.\n\nApply discounting to account for time preferences.\n\nAdjust the transition probabilities for the treatment group using a relative risk measure.\n\nCalculate the treatment group’s total costs.\n\nApply discounting again for the treatment results.\n\nCompare treatment vs. control to calculate the Incremental Cost-Effectiveness Ratio (ICER).",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-3.5---a-time-dependent-markov-model-for-two-hip-replacement-treaments",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-3.5---a-time-dependent-markov-model-for-two-hip-replacement-treaments",
    "title": "Overview of exercises",
    "section": "Exercise 3.5 - A Time-Dependent Markov Model for two Hip-Replacement Treaments",
    "text": "Exercise 3.5 - A Time-Dependent Markov Model for two Hip-Replacement Treaments\nThis exercise extends upon exercise 2.5 by building a time-dependent markov model for two total hip-replacement treatments over 60 years. Specifically, it includes how to use existing mortality rates and risk derived from a survival function to compare the cost and utility of treatments.\n\nSteps\n\nPopulate model parameters using the provided estimates.\n\nCalculate time-dependent transition probabilities using survival analysis results.\nEstimate background mortality rates given the relevant covariates.\n\nBuild the Markov model for the standard intervention.\n\nApply costs and utilities for the standard intervention, including discounting.\n\nRepeat the procedure for the new prosthesis treatment.\nCompare treatment vs. control to calculate the Incremental Cost-Effectiveness Ratio (ICER).",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-4.7-adapt-the-hiv-treatment-model-into-a-probabilistic-version",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-4.7-adapt-the-hiv-treatment-model-into-a-probabilistic-version",
    "title": "Overview of exercises",
    "section": "Exercise 4.7 – Adapt the HIV Treatment Model into a Probabilistic Version",
    "text": "Exercise 4.7 – Adapt the HIV Treatment Model into a Probabilistic Version\nYou will expand the simple model from Exercise 2.5 into a probabilistic Markov model by incorporating uncertainty in parameters by drawing each parameter from a probability distribution.\n\nSteps\n\nAssign a log-normal distribution for relative risks, based on mean and 95% confidence intervals.\n\nUse a gamma distribution for costs, assuming the standard error equals the mean.\n\nUse the Dirichlet distribution to draw values for the transition probability matrix.\nCompare treatment vs. control to calculate the Incremental Cost-Effectiveness Ratio (ICER).\n\nTry running the code again to check that a new ICER is calculated.\nBuild a stand-alone analysis function that automatically calculates the ICER for given parameter inputs.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-4.8-adapt-the-model-into-a-probabilistic-version",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-4.8-adapt-the-model-into-a-probabilistic-version",
    "title": "Overview of exercises",
    "section": "Exercise 4.8 – Adapt the Model into a Probabilistic Version",
    "text": "Exercise 4.8 – Adapt the Model into a Probabilistic Version\nIn this exercise, you will extend the total hip replacement example from Exercise 3.5 to be probabilistic. This involves assigning probability distributions to uncertain parameters including the uncertainty in the survival model.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#steps-3",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#steps-3",
    "title": "Overview of exercises",
    "section": "Steps",
    "text": "Steps\n\nReview all parameter inputs and identify which should remain deterministic (e.g., patient characteristics, prosthesis costs, discount rates) and which should be included in the probabilistic sensitivity analysis.\n\nFit beta distributions for probability parameters, such as post-operative mortality and revision-related mortality, using the provided information.\nFit gamma distributions for cost parameters. Use the method of moments (with the provided mean and standard error) to estimat the parameters of the gamma distribution.\nFit beta distributions for utility parameters. Use the method of moments to estimate the beta parameters from the given means and standard errors.\nUse the multivariate normal distribution with the specified covariance matrix to draw values for the survival parameters.\nBuild a stand-alone analysis function that automatically calculates the ICER for given parameter inputs.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-5.7-use-simulations-and-generate-ce-plane-ceac",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-5.7-use-simulations-and-generate-ce-plane-ceac",
    "title": "Overview of exercises",
    "section": "Exercise 5.7 – Use Simulations and Generate CE Plane & CEAC",
    "text": "Exercise 5.7 – Use Simulations and Generate CE Plane & CEAC\nIn this exercise, you will build a simulation using the probabilistic model from Exercise 4.8 to estimate the uncertainty in the ICER . The goal is to produce both a cost effectiveness plane and a cost effectiveness acceptability curve (CEAC) across the parameter space.\n\nSteps\n\nBuild a simulation function that automates the simulation process including drawing all parameter values and calculating the cost effectiveness cost effectiveness acceptability.\nAnalyze the results and create a cost-effectiveness plane.\n\nRepeat the analysis for different subgroups.\n\nPlot CEACs for each subgroup and compare the results.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-5.8-adding-a-third-treatment-option-to-the-total-hip-replacement-example",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-5.8-adding-a-third-treatment-option-to-the-total-hip-replacement-example",
    "title": "Overview of exercises",
    "section": "Exercise 5.8 – Adding a Third Treatment Option to the total hip replacement example",
    "text": "Exercise 5.8 – Adding a Third Treatment Option to the total hip replacement example\nIn this exercise, you will expand the model by adding a third treatment option. Since all treatment options are mutually exclusive, the analysis requires multiple CEACs and the creation of a cost effectiveness acceptability frontier.\n\nSteps\n\nAdd a third prosthesis option to the model.\n\nRun the simulation, calculate mean results, and plot all options on the cost-effectiveness plane.\n\nUse the net-benefit framework to generate multiple CEACs for the three options and construct the cost-effectiveness acceptability frontier.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-6.6-calculate-the-expected-value-of-perfect-information-evpi",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Overview.html#exercise-6.6-calculate-the-expected-value-of-perfect-information-evpi",
    "title": "Overview of exercises",
    "section": "Exercise 6.6 – Calculate the Expected Value of Perfect Information (EVPI)",
    "text": "Exercise 6.6 – Calculate the Expected Value of Perfect Information (EVPI)\nThis exercise focuses on calculating the non-parametric expected value of perfect information (EVPI) for the total hip replacement example, both at the individual and population level. You will also calculate EVPPI for group of parameters\n\nSteps\n\nCalculate the per-patient EVPI for a new prosthesis from the simulation output.\n\nCompute the mean across net benefits under perfect information, then calculate the difference between the mean of maximized net benefits and the maximum of the mean values to obtain the EVPI at the individual level.\n\nEstimate the effective population size and multiply by individual EVPI to get population EVPI.\n\nCalculate EVPI as a function of the cost-effectiveness threshold and examine the peak value.\n\nCalculate EVPI for the risk-reduction parameter: take net benefits for each intervention across many draws, average them, and then compute the maximum net benefits across draws to estimate the payoff under under perfect information of risk-reduction.\n\nCompute the expected value of perfect parameter information (EVPPI) for all groups of parameters.\nPlot the EVPPI results for all parameters as a bar chart.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Overview of exercises"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html",
    "title": "Exercise 2.5",
    "section": "",
    "text": "Part 1: Populating transition probability matrix\nThis section reproduces exercise 2.5 in R from Chapter 2 of the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nFirst, we will calculate the monotherapy transition probabilities for the control based on the data provided in Table 2.5. These probabilities should match the transition probabilities provided in Table 2.2. part 1(a)\nWe need to calculate the following transition probabilities:\nNow that we have calculated the transition probabilities, we will use these values to populate the transition probability matrix and initialize the parameters necessary for modelling.\nThe matrix will follow the structure below, as shown in table 2.6:\n#         To State\n#           A B C D\n# From    A\n# State   B\n#         C\n#         D\nAs you complete the matrix, remember, that it’s not possible to go backwards in this model, so any transition probability below the diagonal values will be 0.\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\n#please note that there are more decimals here than in Table 2.2a and other figures. This is because we aim to maintain the exact decimals used in the Excel sheet for consistency. To get decimals closer to what we achieve here, we recommend using Table 2.5 as a guide.\nrowSums(tProbs) \n\n[1] 1 1 1 1\nNow that we know our transition matrix is correct, we will fill in the other parameters that are provided in the exercise.\n#costs\ndmca &lt;- 1701 #direct medical cost of A\ndmcb &lt;- 1774 #direct medical cost of B\ndmcc &lt;- 6948 #direct medical cost of C\nccca &lt;- 1055 #community care cost of A\ncccb &lt;- 1278 #community care cost of B\ncccc &lt;- 2059 #community care cost of C\ncAZT &lt;- 2278 #cost of Zidovudine\ncLam &lt;- 2086.5 #cost of Lamivudine \n\n#other parameters\nRR &lt;- 0.509 #relative risk of treatment\ncDR &lt;- 0.06 #annual discount rate cost (proportion)\noDR &lt;- 0 #annual discount rate benefits (proportion)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-1-populating-transition-probability-matrix",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-1-populating-transition-probability-matrix",
    "title": "Exercise 2.5",
    "section": "",
    "text": "ImportantCheck\n\n\n\nWe will use rowSums to make sure we’ve entered our transition matrix correctly. All the rows should equal 1.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAfter each parameter, we’ve used # and a description of what that parameter is so we can easily revisit our code at a future date.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-2-calculating-proportion-of-individuals-in-each-state",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-2-calculating-proportion-of-individuals-in-each-state",
    "title": "Exercise 2.5",
    "section": "Part 2: Calculating proportion of individuals in each state",
    "text": "Part 2: Calculating proportion of individuals in each state\nNow, we will calculate the proportion of individuals in each state for years 1-20 (Monotherapy), their life-years, and associated costs.\nWe will input the initial vector for the state space, where each element refers to the initial proportion of individuals in state A-D respectively.\nWe assume all individuals start in State A. We are giving the vector the name iVec.\n\niVec &lt;- c(1,0,0,0)\n\n\nWe are going to create a function called calculateYearlyProbs that we can use to calculate the proportion of people in each state at a given time point.\nThis function will return a t (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #loop through all time-points and multiply the vector by our transition probability matrix\n  for(i in 1:(t)){\n\n    matReturn[i,] &lt;- iVec %*% tProbs\n    \n    #update iVec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  #returns a t (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n  return(matReturn)\n  \n}\n\n\nNow, we will call the function, by entering our transition probabilities matrix, the number of years we want to calculate, and our starting vector as arguments. We’ve called the results of our function yearlyProbs. It will return a matrix that is 20 rows (years) long and 4 states wide.\n\nyearlyProbs &lt;- calculateYearlyProbs(tProbs,20,iVec)\n\n\n\n\n\n\n\nImportantCheck\n\n\n\nUse rowSums to check that all rows sum to 1.\n\n\n\nrowSums(yearlyProbs)\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nNext we will calculate the number of life years for each year. This is equal to the the proportion that is not in State D (death).\n\nlifeYears &lt;- rowSums(yearlyProbs[,-4])",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-3-calculating-costs",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-3-calculating-costs",
    "title": "Exercise 2.5",
    "section": "Part 3: Calculating costs",
    "text": "Part 3: Calculating costs\nUsing the cost inputs from before, we will calculate the cost. Then, based on those costs, we will calculate the discounted cost using the discounted cost formula provided in the text.\nTo calculate the non-discounted costs, we will calculate a cost associated with each health state in our markov model, and then create a vector to hold the costs associated with each state.\n\ncostA &lt;- dmca+ccca+cAZT\ncostB &lt;- dmcb+cccb+cAZT\ncostC &lt;- dmcc+cccc+cAZT\n\ncostVector &lt;- c(costA,costB,costC)\n\n\nWe will use matrix multiplication to calculate the non-discounted cost. We will multiply yearlyProbs, the matrix holding the proportion in each health state by cycle (i.e. year), by our new costVector.\nRemember, we need to make sure the vector and the matrix have the same number of columns. So, we will use [-4] to remove the death state column from the matrix.\n\nnonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\n\nOur non-discounted costs are saved in nonDiscCost. To get teh discounted cost, we will apply the discounting formula. We will create a discounting function that we can reuse in the future.\nSo we can apply this function to multiple values of t at once we will use R’s vectorization. All basic operations in R “-+^/*” support basic R vectorization.\nThis means we can use the discount formula for all values of t at once (t = 1,..,20). We can do this by using 1:t in place of “t” in the formula\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n\nWe can calculate the discounted costs by filling in the arguments for the newly created discount function.\nWe need to specify: the non-discounted costs; the discount rate; and the number of years you are calculating for.\n\ndiscCost &lt;- discountFormula(nonDiscCost, discRate = cDR,20)\n\n\nWe will use the sum function to calculate the total costs and life years over the 20 years of the Markov model.\n\ntotalDiscCostMonoTherapy &lt;- sum(discCost)\ntotalLifeYearsMonoTherapy &lt;- sum(lifeYears)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-4-conducting-analysis-for-combination-therapy",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-4-conducting-analysis-for-combination-therapy",
    "title": "Exercise 2.5",
    "section": "Part 4: Conducting analysis for combination therapy",
    "text": "Part 4: Conducting analysis for combination therapy\nHaving completed the analysis for the monotherapy, we will repeat the same steps for the combination therapy, with a few changes. Use table 2.2 part 1(b) as a guide to calculate the combination transition matrix. Recall that the combination therapy is only used for the first two years of treatment.\nTo begin, lets create a function that converts the original transition matrix to the combination transition matrix by using the risk ratio provided\n\ncalculateProbCombination &lt;- function(tProbs,RR = 0.506){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\nNow, we will use our function to calculate the transition probabilities for the combination therapy:\n\ntProbsComb &lt;- calculateProbCombination(tProbs,RR = RR)\n\n\n\n\n\n\n\nImportantCheck\n\n\n\nJust like before, we will use rowSums to check that all rows sum to 1.\n\n\n\nrowSums(tProbsComb)\n\n[1] 1 1 1 1\n\n\nThen we will calculate the yearly proportions for the first two years using the function calculateYearlyProbs that we created above. The function arguments will include tProbsComb–the new proportions matrix for the combination therapy.\n\nprobsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n\nWe also need to calculate the yearly proportions for years 3-20. We will use the transition probabilities for monotherapy for these calculations, reflecting that the combination therapy is only used in years 1 and 2.\nWe will then use rbind to combine the two calculations to get the values for years 1-20, and check that each row sums to 1.\n\nprobsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = 18,iVec =probsCombYearly1_2[2,])\n\n#combine them\nprobsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n\n#check\nrowSums(probsCombYearly) # all sum to 1\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\n\nUsing the same approach as for the monotherapy, we will calculate the life years and the costs, being careful to apply the correct costs to the correct proportions.\n\n#calculate the life-years\nlifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n\n#calculate the costs\ncostAComb &lt;- costA+cLam\ncostBComb &lt;- costB+cLam\ncostCComb &lt;- costC+cLam\n#combine the costs into a vector\ncostVectorComb &lt;- c(costAComb,costBComb,costCComb)\n\n#use matrix multiplication\ncostCombNonDisc1_2 &lt;- probsCombYearly[1:2,-4] %*% costVectorComb\ncostCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n\n\nWe will again use rbind to combine the non-discounted costs and then use the discount function to calculate the discounted costs.\nWith the costs and life years calculated for each year, we will use sum to calculate the total costs and life years associated with the combination therapy.\n\n#use rbind to combine the non-discounted cost\ncostCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n\n#calculate the discounted rate\ncostCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,20)\n\n#calculate the total costs and life years for the combination therapy\ntotalLifeYearsComb &lt;- sum(lifeYearsComb)\ntotalDiscCostComb &lt;- sum(costCombDisc)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-5-calculating-the-icer",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch2-Exercise-25.html#part-5-calculating-the-icer",
    "title": "Exercise 2.5",
    "section": "Part 5: Calculating the ICER",
    "text": "Part 5: Calculating the ICER\nLastly, we compare the total life years and costs between the monotherapy and combination therapy to calculate the ICER.\n\n#combination over monotherapy\nlifeYearsGained &lt;- totalLifeYearsComb - totalLifeYearsMonoTherapy\nincreasedCost &lt;- totalDiscCostComb - totalDiscCostMonoTherapy\n\n#calculate ICER\nICER &lt;- increasedCost/lifeYearsGained\n\nICER \n\n[1] 6275.956",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html",
    "title": "Exercise 3.5",
    "section": "",
    "text": "Setup\nThis section reproduces exercise 3.5 in R from Chapter 3 of the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nThis exercise builds upon the skills from exercise 2.5. You will need to know how to build and call functions in R, as well as how to multiply matrices.\nThe following Markov Model will be used in this exercise. Use it to fill in the transition probabilities in the later section. This figure comes directly from the original Excel worksheet provided by Andrew Briggs, Mark Sculpher, and Karl Claxton.\nTo begin, we need to enter our parameter values. Some are are provided directly and some need to be calculated.\nBelow we enter the cost and utility parameters provided.\nmale &lt;- 0 #0 for female, 1 for male\nage &lt;- 60 #average age at receipt for primary implant\n\n#transition probabilities\n#these values are provided at the start of the guide on in section 3.5.2\nomrPTHR &lt;- 0.02 #operative mortality rate for primary THR\nomrRTHR &lt;- 0.02 #operative mortality rate for revision THR\nrrr &lt;- 0.04 #re-revision risk rate\n\n#costs\ncRevision &lt;- 5294 #cost of revisions\ncStandard &lt;- 394 #cost of standard implant\ncNP1 &lt;- 579 #cost of new implant\n\n#discount rates\ncDR &lt;- 0.06 #cost discount\noDR &lt;- 0.015 #outcome discount\n\n#utility of markov states\n#these values are given in Section 3.5.2 1) iii\nuSuccessP &lt;- 0.85 #utility of primary success\nuSuccessR &lt;- 0.75 #utility of revision success\nuRevision &lt;- 0.30 #utility of revision\nNow we will enter the survival model that is fit with a Weibull distribution.\nRemember that the coefficients are on the log scale.\nsurvModelSummary &lt;- data.frame(\n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nTo calculate lambda of the weibull distribution we can take the linear combination of the coefficients. Again, we need to remember to exponentiate the results as they are on the log scale.\nWe can use the $ operator to create new columns in the survModelSummary dataframe and extract any column from the dataframe by name.\nthe $ operator by default extracts a vector, which means vector operations can be done on them such as [i] to extract the ith element of the vector. If you want to refresh your memory on how to use [i] to extract a data element, review exercise 2.5.\n#replace `columnname`\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n#use the $ operator to extract the column of choice then use [i] to extract the coeficient of choice\n#for example [2] corresponds to the constant coefficient \nlnLambda &lt;- survModelSummary$coefficient[2] + survModelSummary$coefficient[3]*age + survModelSummary$coefficient[4]*male\n\n#ensure to exponentiation lambda and gamma as they are in in the log scale\nlambda &lt;- exp(lnLambda)\ngamma &lt;- exp(survModelSummary$coefficient[1])",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-1-calculating-the-transition-probabilities",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-1-calculating-the-transition-probabilities",
    "title": "Exercise 3.5",
    "section": "Step 1: Calculating the transition probabilities",
    "text": "Step 1: Calculating the transition probabilities\nLets create a function to calculate the transition probabilities for a yearly cycle \\(t\\). The formula is given in Section 3.5.2.\nAs we noted above, R is vectorized. That means we can input a vector as an argument and each element of the vector will be passed through.\nWe want all of \\(t\\) = 1,…,60 to be calculated so we can simply use 1:t which creates a vector 1,…,\\(t\\)\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n   \n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n  \n}\n\n\nWe can use this function to calculate the revision risk or the time-dependent transition probability per year.\n\nrevisionRisk &lt;- tProbsHazard(60,lambda = lambda,gamma = gamma)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-2-using-life-tables-for-background-mortality",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-2-using-life-tables-for-background-mortality",
    "title": "Exercise 3.5",
    "section": "Step 2: Using life-tables for background mortality",
    "text": "Step 2: Using life-tables for background mortality\nWe want to make sure we are accounting for background mortality in our model. First, we will add the death rates and yearly transition probabilities provided in the exercise.\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n\nNote that by default this exercise uses female.\nLets create the death risk by analyzing the cycle for those who are female and have an average age of 60 plus the cycle year due to all cause mortality\nTo do this we will us use a special function in R called the apply family. This function takes two arguments x and a function of x. This function is then applied to all elements of x. We can use this to extract the appropriate cell of the yearlyTProbs dataset for all 60 cycles. The apply function family is essentially a wrapper of a for-loop, that can be quickly written. If you prefer the equivalent code, it can be written as a for-loop.\nHere we are using the sum function on a “logical if”. For example we are on cycle 5 then the average patient age is now 5+60 which is 65, then there are 4 rows (which all show up as true or false values) that are less than or equal to 65, taking the sum gives us an index of 4 which is the appropriate index to select.\n\ndeathRisk &lt;- sapply(1:60,function(x){\n  \n  #calculate which index select based on the age group\n  inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n  \n  #select the gender columns\n  genderCol &lt;- ifelse(male ==1,3,4)\n  \n  return(yearlyTProbs[inds,genderCol])\n  \n})\n\n\n\n\n\n\n\nNote\n\n\n\nifelse takes 3 arguments. The first is a logic check. If true, it returns the second value. If false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-3-creating-the-markov-model",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-3-creating-the-markov-model",
    "title": "Exercise 3.5",
    "section": "Step 3: Creating the Markov Model",
    "text": "Step 3: Creating the Markov Model\nTo create the Markov Model, we must specify a transition matrix as in Exercise 2.5 and then calculate the number of individuals in each state for 60 cycles. The change here from Exercise 2.5 is that the transition probabilities change depending on the cycle.\nRevisit the figure shown at the beginning of this exercise.\nIn our matrix, we will et the first column be PrimaryTHR, the second column be Success of primary THR (SuccessP), the third column be Revision THR, the fourth column be Success of Revision (SuccessR), and the fifth column be Death. Thus we will have a 5 state Markov model.\n\n# The matrix will follow this structure, shown in Figure 3.7:\n# \n#                     To State\n#                       PrimaryTHR SuccessP RevisionTHR SuccessR Death\n# From    PrimaryTHR\n# State   SuccessP\n#         RevisionTHR \n#         SuccessR\n#         Death\n\n\nNote that our transition matrix is now time-dependent. That is, depending on the cycle, the transition probability will change. Therefore we must make a function that alters the transition matrix based on the cycle. We will fill in the transition matrix function with the appropriate transition probabilities.\nTo get the \\(t\\)’th value of vector such as mr, we can use the [t] operator.\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n  return(tProbs)\n  \n}\n\n\n\n\n\n\n\nImportantCheck\n\n\n\nManually check that each row sums to 1 by performing some algebra.\n\n\nWe must now calculate the amount of individuals in each state for 60 cycles. We will re-use the function created in exercise 2.5 but modify it slightly for the new Markov model so that it includes the extra states and the time-dependent transition probabilities.\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;- iVec %*% tProbs \n    \n    #update iVec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  return(matReturn)\n  \n}\n\n\nJust like in exercise 2.5, we will create our initial vector. Again, everyone in the population starts in the first state: PrimaryTHR.\n\niVec &lt;- c(1000,0,0,0,0)\n\n\nThen we will calculate all states for all 60 cycles\n\npopulationStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR,omrRTHR,rr= revisionRisk, mr = deathRisk,rrr=rrr,t=60)\n\n\n\n\n\n\n\nImportantCheck\n\n\n\nWe will use rowSums to make sure that all rows total to 1000.\n\n\n\nrowSums(populationStates)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-4-adapt-the-model-for-a-new-prosthesis",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-4-adapt-the-model-for-a-new-prosthesis",
    "title": "Exercise 3.5",
    "section": "Step 4: Adapt the Model for a New Prosthesis",
    "text": "Step 4: Adapt the Model for a New Prosthesis\nTo adapt the model for a new prosthesis, we will re-use the previous results while adding the treatment effect.\nThe new revision risk adjusts the lambda value by a scalar – the hazard ratio of NP1\n\n#use the $ operator to extract the appropriate hazard ratio\nrrNP1 &lt;- survModelSummary$hazard_ratio[5]\nrevisionRiskNP1 &lt;- tProbsHazard(t=60,lambda = lambda*rrNP1,gamma = gamma)\n\n\nWe will calculate the updated states using the calculateYearlyProbs function we created earlier and filling in the appropriate arguments\n\npopulationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=revisionRiskNP1,mr=deathRisk,rrr,t=60)\n\n\n\n\n\n\n\nImportantCheck\n\n\n\nUse rowSums to check that the row totals are equal to 1000.\n\n\n\nrowSums(populationStatesNP1)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-5-caculate-the-costs",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-5-caculate-the-costs",
    "title": "Exercise 3.5",
    "section": "Step 5: Caculate the Costs",
    "text": "Step 5: Caculate the Costs\nWe need to calculate the costs for both the standard and new prosthesis models. To do this, we will use the discount formula from exercise 2.5\n\n#this formula comes directly from the previous exercise\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n\nWe will go through the steps for the standard treatment first\nWe will calculate Life-Years using rowSums, being sure to exclude the last state of death by using the [,-i] operator\n\nlifeYearsStandard &lt;-rowSums(populationStates[,-5])\n\n\nNext, we create the cost vector. The length of the vector should only then be 4, the total of the states with costs in the model.\n\n\n\n\n\n\nNote\n\n\n\nDeath can have costs that you might want to integrate in other models. But in this model, there are no costs associated with death.\n\n\n\ncosts&lt;- c(0,0,cRevision,0)\n\n\nWe need to add a parameter for the initial cost. In this exercise, we started with 1000 patients.\n\niCostStandard &lt;- cStandard*1000\n\n\nWe will calculate the total cost by using matrix multiplication to multiple our cost vector costs by our states matrix populationStates. We will use our discountFormula to account for discounting over time.\n\ntotalCosts &lt;- populationStates[,-5] %*% costs\n\n#update the costs to account for discounting over time\ndiscCostStandard &lt;- discountFormula(totalCosts,cDR,t = 60)\n\n\nNext we need to repeat the previous steps for utility of the treatment over time. Just like for costs, we start by creating a utility vector for all states except death, for which utility = 0.\n\nutility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n\n\nWe will calculate the total utility over time using matrix multiplication and then we will calculate the discounted utility.\n\ntotalQuality &lt;-  populationStates[,-5] %*% utility\nQALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t = 60)\n\n\nLastly, we will calculate the total cost and utilities for all cycles/person, ensuring to include the initial cost of the treatment.\n\nSTDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\nSTDLYs &lt;- sum(lifeYearsStandard)/1000\nSTDQALYS &lt;- sum(QALYStandard)/1000\n\n\n\nRepeat for the new prosthesis (NP1)\nAll steps should be the same for the new prosthesis, with updated costs and utilities\n\n#use rowsums to get the total life years\nlifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n\n#total and discounted costs\ntotalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costs\ndiscCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t = 60)\n\n#add the initial cost for NP1 via cNP1\niCostNP1 &lt;- cNP1*1000\n\n#Utility\ntotalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\nQALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t = 60)\n\n#calculate the total cost for all cycles/person, ensure to add the initial cost of the new implant\nNP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\nNP1LYs &lt;- sum(lifeYearsNP1)/1000\nNP1QALYS &lt;- sum(QALYNP1)/1000",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-6-calculate-the-icer",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch3-Exercise-35.html#step-6-calculate-the-icer",
    "title": "Exercise 3.5",
    "section": "Step 6: Calculate the ICER",
    "text": "Step 6: Calculate the ICER\nThe final step is to calculate the ICER for the new prosthesis compared to standard care.\n\n#calculate the difference in costs\ndiffCost &lt;- NP1cost-STDcost\n\n#difference in QALYs\ndiffQALY &lt;- NP1QALYS-STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 2198.487",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html",
    "title": "Exercise 4.7",
    "section": "",
    "text": "Part 1: Drawing the log-normal distribution\nThis section reproduces exercise 4.7 in R from chapter 4 in the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nThe general idea of this exercise is to revisit exercise 2.5, but add uncertainty in our parameter values by assigning a probability distribution to each parameter. The various probability distributions are described in Chapter 4 and summarized in table 4.9.\nMuch of this exercise will re-use the results and functions from exercise 2.5.\nSome useful functions in R: log(x) by default calculates the natural logarithm of x. R has many built in functions to generate random numbers. For example, rnorm(n,mean,sd) generates n random numbers with mean and sd parameters.\nBecause random draws are taken from many distributions, the results of this exercise will vary for each user. To ensure reproducibility we set a seed which allows the random numbers generated to be the same for all those who use the same seed (provided the operating systems are the same).\nWe will start by setting the seed and adding in the provided parameters.\n#set a seed for reproducibility\nset.seed(123)\n\n##fixed parameters##\nRR &lt;- 0.509 #relative risk of new treatment\ncDR &lt;- 0.06 #discount rate\n\n#the confidence interval\nCI_RR &lt;- c(0.365, 0.710)\n\n#drug costs, these are known and fixed\ncAZT &lt;- 2278 #cost of Zidovudine\ncLam &lt;- 2086.5 #cost of Lamivudine\nWe need to re-arrange the confidence interval formula to calculate the standard error.\nRemember that the normal distribution’s parameters are on the log scale. So, the confidence interval parameters and relative risk must be transformed accordingly.\nSE_RR &lt;- (log(CI_RR[2])-log(CI_RR[1]))/(2*1.96)\nexp(log(RR)-1.96*SE_RR)\n\n[1] 0.3649514\n\nexp(log(RR)+1.96*SE_RR)\n\n[1] 0.7099055\nNext, calculate the log mean and logRR; these are the parameters of the log-normal distribution.\nlnMeanRR &lt;- log(RR)\nlnSERR &lt;- SE_RR\nWe will now draw from the normal distribution.\nlnRRDraw &lt;- rnorm(1,mean = lnMeanRR,sd = lnSERR)\nRRSim &lt;- exp(lnRRDraw)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-1-drawing-the-log-normal-distribution",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-1-drawing-the-log-normal-distribution",
    "title": "Exercise 4.7",
    "section": "",
    "text": "ImportantCheck\n\n\n\nWe can check we’ve done it properly by using the formulas below, They should provide the same results as the confidence intervals we entered above as CI_RR.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-2-using-the-distribution-to-draw-random-costs",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-2-using-the-distribution-to-draw-random-costs",
    "title": "Exercise 4.7",
    "section": "Part 2: Using the distribution to draw random costs",
    "text": "Part 2: Using the distribution to draw random costs\nWe may use the rgamma(m,shape,scale) function to draw random numbers from the gamma distribution. Recall the formulae from 4.4.3 for parameterizing the gamma distribution using the method of moments. Take care to ensure the parameterization of the gamma distribution matches that of 4.4.3. Use rgamma() to check the parameterization. The gamma distribution is parameterized in the textbook as \\(f(x \\mid \\alpha, \\beta) = \\frac{1}{\\Gamma(\\alpha), \\beta^\\alpha} \\, x^{\\alpha-1} \\, e^{-x/\\beta}\\), where \\(\\beta\\) is the “scale” parameter.\nBy default the parameterization should be \\(\\beta\\) = scale.\nFor this exercise we will take the mean costs directly from exercise 2.5 and assume the mean costs for the care are equal to their standard errors. :::{.callout-note} In R we can nest the assignment operator &lt;- to save space :::\n\ndmca &lt;- SEdmca &lt;- 1701 #direct medical cost of A\ndmcb &lt;- SEdmcb &lt;- 1774 #direct medical cost of B\ndmcc &lt;- SEdmcc &lt;- 6948 #direct medical cost of C\nccca &lt;- SEccca &lt;- 1055 #community care cost of A\ncccb &lt;- SEcccb &lt;- 1278 #community care cost of B\ncccc &lt;- SEcccc &lt;- 2059 #community care cost of C\n\nTo simplify calculations, we will create a function that calculates the mean and sd of the gamma distribution based on the mean and standard deviation.\n\ngammaDistAlpha &lt;- function(mean,sd){\n  \n  return((mean^2)/(sd^2))\n  \n}\n\ngammaDistBeta &lt;- function(mean,sd){\n  \n  return((sd^2)/(mean))\n  \n}\n\nNow we will create random draws\n\ndmcaSim &lt;- rgamma(1, shape = gammaDistAlpha(dmca,SEdmca),scale = gammaDistBeta(dmca,SEdmca))\ndmcbSim &lt;- rgamma(1, shape = gammaDistAlpha(dmcb,SEdmcb),scale = gammaDistBeta(dmcb,SEdmcb))\ndmccSim &lt;- rgamma(1, shape = gammaDistAlpha(dmcc,SEdmcc),scale = gammaDistBeta(dmcc,SEdmcc))\n\ncccaSim &lt;- rgamma(1, shape = gammaDistAlpha(ccca,SEccca),scale = gammaDistBeta(ccca,SEccca))\ncccbSim &lt;- rgamma(1, shape = gammaDistAlpha(cccb,SEcccb),scale = gammaDistBeta(cccb,SEcccb))\nccccSim &lt;- rgamma(1, shape = gammaDistAlpha(cccc,SEcccc),scale = gammaDistBeta(cccc,SEcccc))",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-3-generating-new-transition-probability-matrices-using-the-dirichlet-distirbution",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-3-generating-new-transition-probability-matrices-using-the-dirichlet-distirbution",
    "title": "Exercise 4.7",
    "section": "Part 3: Generating new transition probability matrices using the dirichlet distirbution",
    "text": "Part 3: Generating new transition probability matrices using the dirichlet distirbution\nRecall the transition matrix given in exercise 2.5. The exercise in the excel file has the reader separate the matrix into dichotomous and non-dichotomous transition probabilities and generate random numbers using a beta distribution for the dichotomous events and dirichlet distribution for the non-dichotomous events. There is also no dirichlet distribution in Excel.\nIn R we can tackle this issue more easily. We are able to quickly vectorize the random number generation to speed up calculations, and use the MCMCpack library (Martin et al., 2011) to draw from the dirichlet distribution.\nBelow we load in the transition matrix provided in exercise 2.5\n\n#recall the transition matrix from the exercise 2.5\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\nThe equivalent alphas are given (note the deterministic value is alpha / (alpha + beta)), which is exactly the transition matrix given above. The betas are excluded here for simplicity\n\ntAlpha &lt;- matrix(\n  c(1251, 350, 116  , 17 ,\n    0   , 731, 512  , 15 ,\n    0   , 0  , 1312 , 437, \n    0   , 0  , 0    , 1749 #note this alpha is not required as we know all are in the last state\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\nLets use the apply function to quickly draw random numbers from the dirichlet distribution using the function from MCMCpack and apply it to each row of tAlpha. First, we will need load the MCMCpack library. In order to do this, you will need to have it installed. You can install it using this code: install.packages(\"MCMCpack\")\n\n#load library\nlibrary(MCMCpack)\n\nLoading required package: coda\n\n\nLoading required package: MASS\n\n\n##\n## Markov Chain Monte Carlo Package (MCMCpack)\n\n\n## Copyright (C) 2003-2025 Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park\n\n\n##\n## Support provided by the U.S. National Science Foundation\n\n\n## (Grants SES-0350646 and SES-0350613)\n##\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe only give n = 1 to the rdirichlet distribution as it generates a random vector of length(alpha).\n\n\nThe rdirichlet function by default returns the vector of draws by columns, but when we want these results by rows. To get the matrix back into our original form, we can just use the t() function to transpose matrix.\n\n#use \"1\" to specify to apply the function by rows\ntProbRand &lt;- t(apply(tAlpha,1,function(x){\n  \n  return(MCMCpack::rdirichlet(1,x))\n   \n}))\n\n#our new transition probability matrix\ntProbRand \n\n          [,1]      [,2]       [,3]        [,4]\n[1,] 0.7269368 0.2026091 0.05981664 0.010637517\n[2,] 0.0000000 0.5734102 0.41752856 0.009061196\n[3,] 0.0000000 0.0000000 0.75511187 0.244888130\n[4,] 0.0000000 0.0000000 0.00000000 1.000000000\n\n\n\n\n\n\n\n\nTip\n\n\n\nWe could also write: return(rdirichlet(1,x)) without the MCMCpack:: prefix. We’ve added the prefix so we can clearly see where a function comes from. Anything without a prefix is a function from base R, or a function we’ve written ourselves. This is really helpful when you revisit your code, particularly if you are calling functions from many different packages.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-4-re-running-the-markov-model-from-exercise-2.5",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-4-re-running-the-markov-model-from-exercise-2.5",
    "title": "Exercise 4.7",
    "section": "Part 4: Re-running the Markov model from exercise 2.5",
    "text": "Part 4: Re-running the Markov model from exercise 2.5\nNow that we have defined all our parameters in this exercise by drawing from random distributions where appropriate. Let us take the opportunity to merge all of the exercise into one function so that we can call it easily. This function will take in the costs, number of years, transition matrices of the two models, and the discount rate, and then output the costs and life years for each of the two treatments.\nTo begin, we will load in all of our previously built functions.\n\n#ensure to list all the previously built functions over here\ncalculatetProbCombination &lt;- function(tProbs,RR){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n#identical functions\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #loop through all time-points and multiply the vector by our transition probability matrix\n  for(i in 1:t){\n\n    matReturn[i,] &lt;- iVec %*% tProbs\n    \n    #update iVec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  #returns a t (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n  return(matReturn)\n  \n}\n\nThen we will use these functions to create a single analysis function. We can build in an error check to make sure our rows sum to 1 as before.\n\nanalysisFunc &lt;- function(dmca,dmcb,dmcc,ccca,cccb,cccc,RR,cAZT,cALam,cDR,tProbs,iVec,t){\n  \n  #monotherapycost\n  \n  #call the function\n  yearlyProbs &lt;- calculateYearlyProbs(tProbs,t,iVec)\n  lifeYears &lt;- rowSums(yearlyProbs[,-4])\n  \n  costA &lt;- dmca+ccca+cAZT\n  costB &lt;- dmcb+cccb+cAZT\n  costC &lt;- dmcc+cccc+cAZT\n\n  costVector &lt;- c(costA,costB,costC)\n\n  #calculate the non-discounted cost\n  nonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\n  discCost &lt;- discountFormula(nonDiscCost, discRate = cDR,t)\n  #calculate the total costs and life years over the 20 years\n  totalDiscCostMonoTherapy &lt;- sum(discCost)\n  totalLifeYearsMonoTherapy &lt;- sum(lifeYears)\n  \n  #calculate the combination therapy\n  \n  tProbsComb &lt;- calculatetProbCombination(tProbs,RR = RR)\n  \n  #check to ensure all rows sum to 1\n  rowSums(tProbsComb)\n  \n  #calculate the yearly proportions (for the first two years)\n  probsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n  \n  #calculate rest of years\n  probsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = t-2,iVec =probsCombYearly1_2[2,])\n  \n  #combine them\n  probsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n  \n  #calculate the life-years\n  lifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n  \n  #calculate the costs\n  costAComb &lt;- costA+cLam\n  costBComb &lt;- costB+cLam\n  costCComb &lt;- costC+cLam\n  \n  #combine the costs into a vector\n  costVectorComb &lt;- c(costAComb,costBComb,costCComb)\n  \n  #use matrix multiplication to calculate yearly costs\n  costCombNonDisc1_2 &lt;- probsCombYearly[1:2,-4] %*% costVectorComb\n  costCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n  \n  #use rbind to combine the non-discounted cost\n  costCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n  \n  #calculate the discounted costs\n  costCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,t)\n  \n  #calculate the total costs and life years for the combination therapy\n  totalLifeYearsComb &lt;- sum(lifeYearsComb)\n  totalDiscCostComb &lt;- sum(costCombDisc)\n  \n  #return a list of all the relevant values\n  return(list(MonoLYs = totalLifeYearsMonoTherapy,MonoDiscCost = totalDiscCostMonoTherapy,CombLYs = totalLifeYearsComb , CombDiscCost = totalDiscCostComb))\n  \n}",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-5-calculating-the-icer",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-47.html#part-5-calculating-the-icer",
    "title": "Exercise 4.7",
    "section": "Part 5: Calculating the ICER",
    "text": "Part 5: Calculating the ICER\nJust as in exercise 2.5, our last step is to calculate the ICER. We will use the function we created and the new random draws.\n\n#specify the initial vector\niVec &lt;- c(1,0,0,0)\n\n#call our new analysis function\nresults &lt;- analysisFunc(dmca = dmcaSim,dmcb = dmcbSim,dmcc = dmccSim,ccca = cccaSim,cccb = cccaSim,cccc = ccccSim,RR = RRSim,cAZT = cAZT, cALam = cALam, cDR = cDR, tProbs = tProbRand,iVec = iVec,t = 20)\n\nWe can extract any element from the list by its name using the $ operator\n\nICER &lt;- (results$CombDiscCost-results$MonoDiscCost)/(results$CombLYs-results$MonoLYs)\nICER\n\n[1] 2720.033",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html",
    "title": "Exercise 4.8",
    "section": "",
    "text": "Part 1: Assigning beta distributions to probability parameters\nThis section reproduces exercise 4.8 in R from Chapter 4 in the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nThis exercise re-evaluates the hip-replacement analysis from exercise 3.5. However, we assign probability distributions to parameters that are, in general, estimated with uncertainty.\nConsider this quote from 4.8.2 Section 2:\nand\nAs in exercise 4.7, we will start by setting a seed and by loading parameters from the previous exercise.\n#set a seed for reproducibility\nset.seed(12345)\n\n#some deterministic parameters from the previous exercise, no changes are needed\nage &lt;- 60\nmale &lt;- 0\n\n#discount rates\ncDR &lt;- 0.06 \noDR &lt;- 0.015 \n\n#fixed costs\ncStandard &lt;- 394 #cost of standard implant\ncNP1 &lt;- 579 #cost of new implant\n\nomrPTHR &lt;- rbeta(1,2,98)   #operative mortality rate following primary THR\n\n#use the same distribution for the revision risk as no information is provided\nomrRTHR &lt;- rbeta(1,2,98)  #operative mortality rate following revision THR\n  \n\nrrr &lt;- rbeta(1,4,96) #re-revision risk\nNow, let us compare the standard errors of each estimate by using the sampling distribution based on the central limit theorem, and the method of moments of the beta distribution.\nWe will create a function to calculate the standard errors.\nSE_p &lt;- function(p,n){\n   \n  return(sqrt(p*(1-p)/n))\n  \n}\n\nSE_beta &lt;- function(alpha,beta){\n\n  return(sqrt(alpha*beta/((alpha+beta)^2 *(alpha+beta+1))))\n   \n}\nNow we will use those functions to calculate the standard errors:\n#SE omPTHR\nSE_omrPTHR_p &lt;- SE_p(0.02,100) \nSE_omrPTHR_beta &lt;- SE_beta(2,98)\n\n#SE rrr\nSE_rrr_p &lt;- SE_p(0.04,100) \nSE_rrr_beta &lt;- SE_beta(4,96)\nLets compare the two standard errors\nSE_rrr_p\n\n[1] 0.01959592\n\nSE_rrr_beta\n\n[1] 0.01949867\nNotice that the two standard errors are almost identical with the absolute difference being about 0.0001, this shows that using method of moments with the beta distribution can approximate the standard error of the the sample proportion",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-1-assigning-beta-distributions-to-probability-parameters",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-1-assigning-beta-distributions-to-probability-parameters",
    "title": "Exercise 4.8",
    "section": "",
    "text": "“The hospital records of a sample of 100 patients receiving a primary THR were examined retrospectively. Of these patients, two patients died either during or immediately following the procedure. The operative mortality for the procedure is therefore estimated to be 2 per cent.”\n\n\n\n“The hospital records of a sample of 100 patients having experienced a revision procedure to replace a failed primary THR were reviewed at one year. During this time, four patients had undergone a further revision procedure.”",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-2-using-the-gamma-distribution-for-costs",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-2-using-the-gamma-distribution-for-costs",
    "title": "Exercise 4.8",
    "section": "Part 2: Using the gamma distribution for costs",
    "text": "Part 2: Using the gamma distribution for costs\nConsider the following verbatim quote from Section 4.8.2 Part 3:\n\n“A number of units involved in THR were reviewed and the mean cost of a revision procedure was found to be £5294 with a standard error of £1487.”\n\nThe gamma distribution is parameterized in the textbook as: \\[f(x \\mid \\alpha, \\beta) = \\frac{1}{\\Gamma(\\alpha), \\beta^\\alpha} \\, x^{\\alpha-1} \\, e^{-x/\\beta}\\] where \\(\\beta\\) is the “scale” parameter. To match this parameterization we must use the scale parameter rather than the rate parameter when inputting \\(\\beta\\).\nWe will fill in the mean and SE for the gamma distribution using the method of moments, and ensure we select scale for the beta value as there is a rate parameter (1/scale)\n\nalpha &lt;- (5294/1487)^2\nbeta &lt;- 1487^2 / 5294\n\n#select scale for the beta value as there is a rate parameter\ncRevision &lt;- rgamma(1,shape = alpha,scale = beta)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-3-using-the-beta-distribution-to-generate-utility-parameters",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-3-using-the-beta-distribution-to-generate-utility-parameters",
    "title": "Exercise 4.8",
    "section": "Part 3: Using the beta distribution to generate utility parameters",
    "text": "Part 3: Using the beta distribution to generate utility parameters\nConsider using the method of moments to draw from the beta distribution based on the this quote from Section 4.8.2 Section 3:\n\n“A study was instigated to explore the utility weights subjects placed on different outcomes of THR related to the states of the Markov model – the following results were calculated in terms of mean (standard error) by state:\n\nSuccessful primary – 0.85 (0.03)\nSuccessful revision – 0.75 (0.04)\nRevision – 0.3 (0.03)”\n\n\nBecause we need to calculate alpha and beta for the beta distribution simultaneously as the beta depends on alpha, we can merge all operations into one function.\nWe will create a function that calculates alpha and beta from the mean and standard errors and subsequently draws from the beta distribution.\n\ndrawBetaMethodMoments &lt;- function(n,mu,s){\n  \n  #functions estimates alpha and beta using the method of moments \n  #then draws from the beta distribution\n  alpha &lt;- ((mu*(1-mu)/s^2) -1)*mu\n  beta &lt;- alpha*(1-mu )/mu\n  \n  #draw our random number\n  draw &lt;- rbeta(n,alpha,beta)\n  \n  return(draw)\n  \n}\n\nNow we will draw our beta distribution based on the mean and standard errors using our newly created function.\n\nuSuccessP &lt;- drawBetaMethodMoments(1,0.85,0.03)\nuSuccessR &lt;- drawBetaMethodMoments(1,0.75,0.04)\nuRevision &lt;- drawBetaMethodMoments(1,0.3,0.03)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-4-drawing-from-a-multivariate-normal-distribution",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-4-drawing-from-a-multivariate-normal-distribution",
    "title": "Exercise 4.8",
    "section": "Part 4: Drawing from a multivariate normal distribution",
    "text": "Part 4: Drawing from a multivariate normal distribution\nOne of the advantages R has over Excel is that it has access to morespecialized functions. The excel exercise has the reader generate multivariate normal random numbers via the uni-variate normal distribution. Although there is some nice theory regarding the univariate and multivariate normal distributions, in R we can simply draw directly from a multivariate normal distribution via well established packages such as MASS to simulate the hazard model from exercise 3.5\nFor example the mvrnorm() distribution only requires the covariance matrix, and a cholesky decomposition is not required (although it would likely be more computationally efficient). On modern hardware, there is little difference unless we are generating multivariate normals with very high dimensionality.\n\n\n\n\n\n\nNote\n\n\n\nIf you don’t have MASS installed, you will need to install the package using this code: install.packages(\"MASS\")\n\n\nTo start, we will load the MASS package and input the survival model and covariance matrix provided in the exercise.\n\n#load the package\nlibrary(MASS)\n\n#the survival model from exercise 3.5\nsurvModelSummary &lt;- data.frame(\n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n#covariance matrix provided\ncovMat &lt;- matrix(\n  c(0.0022515  , -0.005691 , 0.000000028, 0.0000051, 0.000259,\n   -0.005691   ,  0.0432191,-0.000783   ,-0.007247 ,-0.000642,\n    0.000000028, -0.000783 , 2.716e-05  , 0.000033 ,-0.000111,\n    0.0000051  , -0.007247 , 0.000033   , 0.0118954, 0.000184,\n    0.000259   , -0.000642 ,-0.000111   , 0.000184 , 0.1463686),\n  nrow = 5, ncol = 5, byrow = T\n)\n\n#name the matrix columns and rows\ncolnames(covMat) &lt;- rownames(covMat) &lt;- c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\")\n\nAlthough we don’t need to, it’s worth noting that we can easily calculate the cholesky decomposition in R\n\ncholeskyMat &lt;- chol(covMat)\n\n\n\n\n\n\n\nImportantCheck\n\n\n\nCompare the coefficient values from normDraw with those from survModelFit. The coefficients should be of similar magnitude and direction but the exact values may differ.\n\n\n\nnormDraw &lt;- MASS::mvrnorm(1, mu = survModelSummary$coefficient,Sigma = covMat)\n\nnormDraw\n\n    lngamma        cons         age        male         NP1 \n 0.44769044 -5.87151659 -0.03006434  0.81474363 -1.30267885 \n\n\nRemember these values are on the log scale.\nWe can extract the necessary parameters using the [i] operator, or, since the vector has named elements, we can be more explicit by using ['name'] instead\n\ngamma &lt;- exp(normDraw['lngamma'])\nlambda &lt;- exp(normDraw['cons'] + normDraw['age']*age + normDraw['male']*male)\nrrNP1 &lt;- exp(normDraw['NP1'])",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-5-combining-all-our-functions",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-5-combining-all-our-functions",
    "title": "Exercise 4.8",
    "section": "Part 5: Combining all our functions",
    "text": "Part 5: Combining all our functions\nWe combine all the functions built in the exercise 3.5 to create an analysis function that completes the NP1 ICER calculations in a single call.\nAs in Exercise 4.7, we create an analysis function that takes in all necessary parameters and outputs the appropriate cost and QALYs to calculate the ICER.\nThe first step is to load in all of our previous functions\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n   \n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n  \n}\n\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n  return(tProbs)\n  \n}\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;- iVec %*% tProbs \n    \n    #update iVec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  #returns a t (years) x 5 (states) matrix where the rows represent \n  #the proportion in a given state at year t\n  return(matReturn)\n  \n}\n\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\nThen we compile all the functions into a single analysis function:\n\nanalysisNP1 &lt;- function(omrPTHR,omrRTHR,mr,rrr,cPrimary,cRevision,cPSuccess,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){\n\n  #calculate the revision risk\n   rr &lt;- tProbsHazard(t=t,lambda = lambda,gamma = gamma)\n   mr &lt;- sapply(1:t,function(x){\n    \n    #calculate which index select based on the age group\n    inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n    \n    #select the gender columns\n    #if else takes 3 arguments, the first is a logical check, \n    #if true, it returns the second value, \n    #if false it returns the 3rd argument. \n    #Equivalent code can be written use if(x){}else{}.\n    genderCol &lt;- ifelse(male ==1,3,4)\n    \n    return(yearlyTProbs[inds,genderCol])\n    \n  })\n    \n  #calculate standard states\n  standPopStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)\n  lifeYearsStandard &lt;- rowSums(standPopStates[,-5])\n  #excludes death year\n  costVec &lt;- c(0,0,cRevision,0)\n\n  #add a parameter for the initial cost we had 1000 initial patients\n  iCostStandard &lt;- cStandard*1000\n  \n  #first calculate the total cost\n  totalCosts &lt;- standPopStates[,-5] %*% costVec\n  \n  #calculate the discounted cost\n  discCostStandard &lt;- discountFormula(totalCosts,cDR,t=t)\n  \n  #calculate the quality adjusted life years by creating \n  #a vector for each state utility except death\n  utility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n  \n  #multiply by the cohort\n  totalQuality &lt;- standPopStates[,-5] %*% utility\n  QALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  STDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\n  STDLYs &lt;- sum(lifeYearsStandard)/1000\n  STDQALYS &lt;- sum(QALYStandard)/1000\n\n  \n  ###repeat this for the NP1###\n  rrNP1_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np1\n  lifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n  \n  #total and discounted costs\n  totalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costVec\n  discCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t=t)\n  #add the initial cost for NP1\n  iCostNP1 &lt;- cNP1*1000\n  #Utility\n  totalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\n  QALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\n  NP1LYs &lt;- sum(lifeYearsNP1)/1000\n  NP1QALYS &lt;- sum(QALYNP1)/1000\n  \n  #returns a list of discounted cost and QALYs for each method\n  return(list(STDcost = STDcost, STDQALYS = STDQALYS, NP1cost = NP1cost,NP1QALYS = NP1QALYS, ICER = (NP1cost-STDcost)/(NP1QALYS-STDQALYS)))\n  \n}",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-6-calculating-the-icer",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch4-Exercise-48.html#part-6-calculating-the-icer",
    "title": "Exercise 4.8",
    "section": "Part 6: Calculating the ICER",
    "text": "Part 6: Calculating the ICER\nNow we will use our analysis function to calculate the ICER.\nWe will need to provide the starting vector, and the number of cycles we want to calculate, and then we can load our arguments into the primary analysis function.\n\n#call the created function\niVec &lt;- c(1000,0,0,0,0)\nt &lt;- 60\n\nresults &lt;- analysisNP1(omrPTHR,omrRTHR,mr,rrr,cPrimary,cRevision,cPSuccess,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t)\n\nWe will use these results to calculate the differences in costs and QALYs, and then compute the ICER.\n\n#calculate the difference in costs\ndiffCost &lt;- results$NP1cost-results$STDcost\n\n#difference in QALYs\ndiffQALY &lt;- results$NP1QALYS-results$STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 1185.616",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html",
    "title": "Exercise 5.7",
    "section": "",
    "text": "Part 1: Setting-up the analysis\nThis section reproduces exercise 5.7 in R from Chapter 5 in the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nIn this exercise we are going to extend the probabilistic parameter generation from exercise 4.8 by using simulations to account for the combined uncertainty of the parameters. As R is a language specifically for statistical computing, it is not surprising that statistical simulations are frequently run in R. These simulations can be constructed using a variety of core R functions. In this exercise, we will use either for-loops directly or call wrappers such as lapply, apply, or sapply.\nLet’s revisit exercise 4.8 by creating a few more functions that:\nFirst we copy the analysis function from 4.8 and create another function that generates parameters.\nWe start by initializing all fixed parameters, bring over all the functions from the previous exercises. We also load the MASS package required to sample random numbers from the multivariate normal distribution.\nlibrary(MASS)\n\ncStandard &lt;- 394 #cost of standard implant\ncNP1 &lt;- 579 #cost of new implant\n\ncDR &lt;- 0.06 #cost discount rate\noDR &lt;- 0.015 #outcome discount rate\nage &lt;- 60 #average age of all patients at receipt of primary implant\nmale &lt;- 0 #sex indicator (0 for female, 1 for male)\n\niVec &lt;- c(1000,0,0,0,0) #starting vector; everyone starts in the first state\nt &lt;- 60 #number of cycles\n\ncovMat &lt;- matrix(\n  c(0.0022515  , -0.005691 , 0.000000028, 0.0000051, 0.000259,\n   -0.005691   ,  0.0432191,-0.000783   ,-0.007247 ,-0.000642,\n    0.000000028, -0.000783 , 2.716e-05  , 0.000033 ,-0.000111,\n    0.0000051  , -0.007247 , 0.000033   , 0.0118954, 0.000184,\n    0.000259   , -0.000642 ,-0.000111   , 0.000184 , 0.1463686),\n  nrow = 5, ncol = 5, byrow = T\n)\n\ncolnames(covMat) &lt;- rownames(covMat) &lt;- c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\")\n\nsurvModelSummary &lt;- data.frame(\n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n\n\n\ndrawBetaMethodMoments &lt;- function(n,mu,s){\n  \n  #functions estimates alpha and beta using the method of moments then draws from the beta distribution\n  alpha &lt;- ((mu*(1-mu)/s^2) -1)*mu\n  beta &lt;- alpha*(1-mu )/mu\n  \n  #draw our random number\n  draw &lt;- rbeta(n,alpha,beta)\n  \n  return(draw)\n  \n}\n\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n   \n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n   \n}\n\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #omrPTHR is operative mortality rate following primary THR\n  #omrRTHR is operative mortality rate following revision THR\n  #rrr is re-revision risk\n  #mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n  return(tProbs)\n  \n}\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;- iVec %*% tProbs \n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  return(matReturn)\n  \n}\n\n\n#complete primary analysis function for NP1\nanalysisNP1 &lt;- function(omrPTHR,omrRTHR,mr,rrr,rrNP1,cPrimary,cRevision,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){\n\n  #calculate the revision risk\n  rr &lt;- tProbsHazard(t=t,lambda = lambda,gamma = gamma)\n  mr &lt;- sapply(1:t,function(x){\n    \n    #calculate which index select based on the age group\n    inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n    \n    #select the gender columns\n    #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n    genderCol &lt;- ifelse(male ==1,3,4)\n    \n    return(yearlyTProbs[inds,genderCol])\n    \n  })\n    \n  #calculate standard states\n  standPopStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)\n  lifeYearsStandard &lt;- rowSums(standPopStates[,-5])\n  #excludes death year\n  costVec &lt;- c(0,0,cRevision,0)\n\n  #add a parameter for the initial cost we had 1000 initial patients\n  iCostStandard &lt;- cStandard*1000\n  \n  #first calculate the total cost\n  totalCosts &lt;- standPopStates[,-5] %*% costVec\n  \n  #calculate the discounted cost\n  discCostStandard &lt;- discountFormula(totalCosts,cDR,t=t)\n  \n  #calculate the quality adjusted life years by creating a vector for each state utility except death\n  utility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n  \n  #multiply by the cohort\n  totalQuality &lt;- standPopStates[,-5] %*% utility\n  QALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  STDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\n  STDLYs &lt;- sum(lifeYearsStandard)/1000\n  STDQALYS &lt;- sum(QALYStandard)/1000\n\n  \n  ###repeat this for the NP1###\n  rrNP1_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np1\n  lifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n  \n  #total and discounted costs\n  totalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costVec\n  discCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t=t)\n  #add the initial cost for NP1\n  iCostNP1 &lt;- cNP1*1000\n  #Utility\n  totalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\n  QALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\n  NP1LYs &lt;- sum(lifeYearsNP1)/1000\n  NP1QALYS &lt;- sum(QALYNP1)/1000\n  \n  #returns a list of discounted cost and QALYs for each method\n  return(list(STDcost = STDcost, STDQALYS = STDQALYS, NP1cost = NP1cost,NP1QALYS = NP1QALYS, ICER = (NP1cost-STDcost)/(NP1QALYS-STDQALYS)))\n  \n}",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-1-setting-up-the-analysis",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-1-setting-up-the-analysis",
    "title": "Exercise 5.7",
    "section": "",
    "text": "Now we will create our simulation function.\nWe start by initializing a dataframe to store our results, then iterating through each parameter and running our analysis function. This could be created using lapply, however it is probably easier to view the logic by using a for-loop.\nThis simulation function will encapsulate all statistics (functions of the data) or almost all values necessary to calculate the cost-effectiveness. However, due to R’s vectorization, and the fact that the cost effectiveness metrics are functions of other columns. We could alternatively calculate many of the metrics after the simulation is completed using R’s vectorization.\nIn the following Code:\n\nNMB refers to “Net Monetary Benefit”\nCE refers to “Cost effective”\n\nCreate our simulation function here:\n\ngenerateSimulations &lt;- function(nReps = 1000,age=60,male=0,cRatio = 100000){\n   \n   #we need to know how many columns or variable we have here in ncol\n   cols &lt;- c(\"omrPTHR\",\"omrRTHR\",\"rrNP1\",\"rrr\",\"lambda\",\"gamma\",\n             \"cPrimary\",\"cRevision\",\"cSuccess\",\"uSuccessP\",\"uSuccessR\",\n             \"uRevision\",\"cRatio\",\"STDCost\",\"STDQALYS\",\"NP1Cost\",\"NP1QALYS\",\n             \"STDNMB\",\"NP1NMB\",\"NP1Inc\",\"CESTD\",\"CENP1\",\"CENP1Inc\")\n   \n   dfReturn &lt;- data.frame(matrix(NA,nrow = nReps,ncol = length(cols)))\n  \n   #fill out the column names for our dataframe\n   colnames(dfReturn) &lt;- cols\n\n   #cRatio is fixed at 100000\n   #This is the threshold ratio\n   dfReturn$cRatio &lt;- cRatio\n   alpha &lt;- (5294/1487)^2\n   beta &lt;- 1487^2 / 5294\n   \n   #due to R's vectorization, we can sample all the parameters at once in the \"n\" parameter\n   omrPTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following primary THR\n   omrRTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following revision THR\n   rrr &lt;- rbeta(nReps,4,96) #re-revision risk\n   \n   #save them here using R's vectorization\n   dfReturn$omrPTHR &lt;- omrPTHR\n   dfReturn$omrRTHR &lt;- omrRTHR \n   dfReturn$rrr &lt;- rrr\n   \n   #cost and utility\n   cRevision &lt;- rgamma(nReps,shape = alpha,scale = beta)\n   uSuccessP &lt;- drawBetaMethodMoments(nReps,0.85,0.03)\n   uSuccessR &lt;- drawBetaMethodMoments(nReps,0.75,0.04)\n   uRevision &lt;- drawBetaMethodMoments(nReps,0.3,0.03)\n   \n   dfReturn$cRevision &lt;- cRevision\n   dfReturn$uSuccessP &lt;- uSuccessP\n   dfReturn$uSuccessR &lt;- uSuccessR\n   dfReturn$uRevision &lt;- uRevision \n   \n   #draw from multivariate normal\n   normDraw &lt;- MASS::mvrnorm(nReps, mu = survModelSummary$coefficient,Sigma = covMat)\n   \n   #using R's vectorization, we can calculate operations on the entire vector, we must use [,\"name\"]as normDraw is not a matrix rather than a vector\n   lambda &lt;- exp(normDraw[,'cons'] + normDraw[,'age']*age + normDraw[,'male']*male)\n   gamma &lt;- exp(normDraw[,'lngamma'])\n   rrNP1 &lt;- exp(normDraw[,'NP1'])\n   \n   dfReturn$lambda &lt;- lambda\n   dfReturn$gamma &lt;- gamma\n   dfReturn$rrNP1 &lt;- rrNP1\n\n  #start the for-loop\n  \n  for(i in 1:nReps){\n    \n    #call the analysis function and specify the iteration for the parameter to be selected\n    #those with a parameter that is constant do not need to be called from dfReturn\n    results &lt;- analysisNP1(dfReturn$omrPTHR[i],dfReturn$omrRTHR[i],mr,dfReturn$rrr[i],dfReturn$rrNP1[i],\n                           dfReturn$cPrimary[i],dfReturn$cRevision[i],dfReturn$cStandard[i],dfReturn$uSuccessP[i],\n                           dfReturn$uSuccessR[i],dfReturn$uRevision[i],cDR,oDR,cNP1,dfReturn$gamma[i],dfReturn$lambda[i],iVec,t)\n    \n    #save the results\n    dfReturn$STDCost[i] &lt;- results$STDcost\n    dfReturn$STDQALYS[i] &lt;- results$STDQALYS\n    dfReturn$NP1Cost[i] &lt;- results$NP1cost\n    dfReturn$NP1QALYS[i] &lt;- results$NP1QALYS\n    \n    #calculate net monetary benefit\n    dfReturn$STDNMB[i] &lt;- results$STDQALYS*dfReturn$cRatio[i]-results$STDcost\n    dfReturn$NP1NMB[i] &lt;- results$NP1QALYS*dfReturn$cRatio[i]-results$NP1cost\n    dfReturn$NP1Inc[i] &lt;- (results$NP1QALYS-results$STDQALYS)*dfReturn$cRatio[i] - (results$NP1cost-results$STDcost)\n    \n    #calculate the cost effectiveness\n    dfReturn$CESTD[i] &lt;- ifelse(dfReturn$STDNMB[i]&gt;= dfReturn$NP1NMB[i],1,0)\n    dfReturn$CENP1[i] &lt;- ifelse(dfReturn$CESTD[i]==1,0,1)\n    dfReturn$CENP1Inc[i] &lt;- ifelse(dfReturn$NP1Inc[i]&gt;0,1,0)\n    \n    #the above formulae come directly from the textbook 5.1.4\n  }\n   \n  return(dfReturn)\n   \n}",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-2-calling-our-simulation-function-plotting-our-cost-effectiveness-plane",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-2-calling-our-simulation-function-plotting-our-cost-effectiveness-plane",
    "title": "Exercise 5.7",
    "section": "Part 2: Calling our simulation function & plotting our cost-effectiveness plane",
    "text": "Part 2: Calling our simulation function & plotting our cost-effectiveness plane\nIn this section we will be using ggplot2 to plot our results. ggplot2 is generally the plotting package of choice in R and has it own unique syntax. If you don’t have ggplot2 installed, you can install it using install.packages(\"ggplot2\")\n\n\n\n\n\n\nTip\n\n\n\nWe suggest briefly reviewing https://ggplot2.tidyverse.org/articles/ggplot2.html to get a sense of how ggplot2 works. We will provide the syntax here.\n\n\nWe will begin by loading the ggplot2 library and setting our starting seed.\n\nlibrary(ggplot2)\n\nset.seed(1)\n\nWe can call the simulation by specifying any number of repetitions after the nReps = argument\n\nres &lt;- generateSimulations(nReps = 1000)\n\nNow we will quickly create the difference in costs and difference in QALYs for each intervention.\nBecause we have access to all columns we can quickly perform vector operations on them.\n\nres$diffCost &lt;- res$NP1Cost-res$STDCost\nres$diffQALYs &lt;- res$NP1QALYS-res$STDQALYS\n\nWe will use these calculations to create a plot using ggplot2\nThe syntax takes a bit of getting used to but the plots are generally quite pretty.\n\nggplot(res,\n       aes(\n         x = diffQALYs,\n         y = diffCost)) + \n      geom_point(\n        colour = \"#414487\") + \n      theme_minimal() + \n      labs(\n        x = \"QALYs\", \n        y = \"Cost\", \n        title = \"Increase in cost effectiveness plane\")",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-3-adding-a-threshold",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-3-adding-a-threshold",
    "title": "Exercise 5.7",
    "section": "Part 3: Adding a threshold",
    "text": "Part 3: Adding a threshold\nLet’s analyse the proportion of our simulation based on the threshold ratio that we specified earlier of $100,000/QALY.\nLet’s also consider changing the threshold value by looping through various possibilities.\n\n#mean proportion of STD cost effective\nmean(res$CESTD)\n\n[1] 0.002\n\n#mean proportion of NP1 cost effective\nmean(res$CENP1)\n\n[1] 0.998\n\n#equivalently, the same NP1 net monetary benefit as the \"increase\" over the standard\nmean(res$CENP1Inc)\n\n[1] 0.998\n\n\nThe NP1 implant is chosen over the standard implant 99.9% of the time with a cost threshold of $100,000/QALY.\nWhat if instead we want to see what happens if we plot this threshold value from 0 to 100,000? We can estimate this numerically by running our simulation many times for different values of cRatio and plotting the results\n\ncRatios &lt;- seq(0, 100000, by = 2500)\n\nTo loop through the cRatios and calculate the proportion of cost effectiveness we can write another for-loop or… instead since cRatios is a vector, we can use sapply to quickly loop through the vector and calculate the proportion output from the resultsNP1() function.\n\ncRatioResults &lt;- sapply(cRatios,function(x){\n  \n  #call the simulation\n  NP1sim &lt;- generateSimulations(nReps = 1000,cRatio = x)\n  \n  #calculate the proportion for each simulatiom\n  propNP1CE &lt;- mean(NP1sim$CENP1)\n  \n  return(propNP1CE)\n  \n})\n\nncRatios &lt;- length(cRatios)\ndfcRatios &lt;- data.frame(cRatio = cRatios,probCENP1 = cRatioResults,probCESTD = 1-cRatioResults)\n\nNow we can plot our results using ggplot2.\n\nggplot(dfcRatios,\n       aes(\n         x = cRatio,\n         y = probCENP1)) + \n      geom_line(\n        colour = '#414487',\n        linewidth = 1.2) + \n      theme_minimal()+ \n      labs(\n        x = \"Value of ceiling ratio\", \n        y = \"Proportion of cost-effective of NP1 treatment\", \n        title = \"Proportion of cost effective by value of ceiling ratio\",\n        colour = \"Treatment\") \n\nIgnoring unknown labels:\n• colour : \"Treatment\"",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-4-examining-subgroups",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-57.html#part-4-examining-subgroups",
    "title": "Exercise 5.7",
    "section": "Part 4: Examining subgroups",
    "text": "Part 4: Examining subgroups\nUp to this point, we have only been looking at one age category and one gender. Let’s now build a function that loops through all possible combinations of age and gender and evaluate the proportion of cost-effectiveness treatment of NP1.\nInstead of using the convenient sapply() as in the previous part, we will use a for-loop to explicitly show which intersection of the subgroup is being analyzed.\nWe’ll start by specifying our subgroups of interest\n\nages &lt;- c(40,60,80)\ngender &lt;- c(0,1)\n\nNow, all possible combinations of these values can be easily calculated using expand.grid, note we also want all possible ceiling ratios (cRatios).\n\nfactorsOfInterest &lt;- expand.grid(cRatio = cRatios, age=ages, male = gender)\n\nWe want to add the column that we will hold our results\n\nfactorsOfInterest$propNP1CE &lt;- NA\n\nWe will then loop through the grid and perform the simulation on each row. Below we specify our function,\n\nsubGroupSimulation &lt;- function(nReps,factorsOfInterest){\n   \n  #calculate the number of combinations\n  nCombinations &lt;- nrow(factorsOfInterest)\n  \n  for(c in 1:nCombinations){\n  \n  #our current combination of the loop (current row)\n  currentCombination &lt;- factorsOfInterest[c,]\n  \n  #call our simulation function\n  NP1sim &lt;- generateSimulations(nReps = nReps, cRatio = currentCombination$cRatio ,age = currentCombination$age, male = currentCombination$male)\n  \n  #calculate the proportion of cost effectiveness\n  propNP1CE &lt;- mean(NP1sim$CENP1)\n  \n  #fill in the dataframe with the proportion\n  factorsOfInterest$propNP1CE[c] &lt;- propNP1CE\n  }\n  \n  return(factorsOfInterest)\n  \n}\n\nNow we’ll use our function to calculate our results\n\nsubGroupResults &lt;- subGroupSimulation(1000,factorsOfInterest)\n\nTo make plotting easier, we will combine the age and gender columns so that they are in one variable\n\nsubGroupResults$combined_factor &lt;- interaction(as.factor(subGroupResults$age),as.factor(subGroupResults$male),sep = \"_\")\n\nWe will again plot the results using ggplot2. This time, we manually change the names of the subgroups to provide appropriate labels in our graph.\n\n\n\n\n\n\nTip\n\n\n\nYou can specify colours for your graph by writing the colour names directly (e.g., “blue”) or by entering hex codes as we have here. In this example, we’ve used 6 colours from the viridis colour palette because it is an accessible color palette and renders well in grey scale. https://search.r-project.org/CRAN/refmans/viridisLite/html/viridis.html\n\n\n\nggplot(subGroupResults,\n       aes(\n         x = cRatio,\n         y = propNP1CE,\n         colour = combined_factor)) + \n      geom_line(\n        linewidth = 1.2,\n        alpha = 0.8) + \n      labs(\n        x = \"Threshold Ratio\", \n        y = \"Proportion of NP1 cost effective\", \n        title = \"Line plot of cost effectiveness of NP1 implant by age and gender\", \n        colour = 'Factor') +\n      scale_color_manual(\n        labels = c(\"40_0\"=\"Female Age 40\",\"60_0\"= \"Female Age 60\",\"80_0\"=\"Female Age 80\", \"40_1\"=\"Male Age 40\",\"60_1\"= \"Male Age 60\",\"80_1\"=\"Male Age 80\"),\n        values = c(\"40_0\" = \"#fde725\",\"60_0\" = \"#7ad151\",\"80_0\" = \"#22a884\", \"40_1\" = \"#2a788e\", \"60_1\" = \"#414487\",\"80_1\" = \"#440154\"))",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html",
    "title": "Exercise 5.8",
    "section": "",
    "text": "Setup\nThis section reproduces exercise 5.8 in R from Chapter 5 of the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton.\nIn this exercise we will build upon the pre-existing prosthesis example, and explore the idea of adding a third prosthesis option, which we will refer to as “NP2”. We will now update the hazard function estimates with the additional NP2 variable, and the corresponding covariance matrix. Note that neither the estimates nor the standard errors for any of the variables will be the same when we add a new variable in the model. Note the coefficients and the variance matrix is one dimension larger due to the addition of the NP2 effect.\nlibrary(MASS)\n\n##fixed parameters## \n\ncStandard &lt;- 394 #cost of standard prosthesis\ncNP1 &lt;- 579 #cost of new prosthesis 1\ncNP2 &lt;- 788 #cost of new prosthesis 2\n\ncDR &lt;- 0.06 #cost discount rate\noDR &lt;- 0.015 #outcome discount rate\nage &lt;- 60 #average age of all patients at receipt of primary implant\nmale &lt;- 0 #sex indicator (0 for female, 1 for male)\n\niVec &lt;- c(1000,0,0,0,0) #starting vector; everyone starts in the first state\nt &lt;- 60 #number of cycles\n\n#fixed mortality rates and transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\nNote the modified covMat and survModelSummary\ncovMat &lt;- matrix(\n  c(0.0022515  , -0.005691 , 0.000000028, 0.0000051 , 0.000259   , 0.000351,\n   -0.005691   ,  0.0432191,-0.000783   ,-0.007247  ,-0.000642   ,-0.000537,\n    0.000000028, -0.000783 , 2.716e-05  , 0.000033  ,-0.000111   ,-0.000299,\n    0.0000051  , -0.007247 , 0.000033   , 0.0118954 , 0.000184   , 0.000098,\n    0.000259   , -0.000642 ,-0.000111   , 0.000184  , 0.1463686  , 0.00035468,\n    0.000351   , -0.000537 ,-0.000299   , 0.000098  , 0.00035468 , 0.267964628   ),\n  nrow = 6, ncol = 6, byrow = T\n)\n\ncolnames(covMat) &lt;- rownames(covMat) &lt;- c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\",\"NP2\")\n\n#if we need cholesky decomposition\ncholcovMat &lt;- chol(covMat)\n\nsurvModelSummary &lt;- data.frame(\n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\",\"NP2\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474,-1.6687),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815,0.517653)\n)\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html#part-1-bringing-in-helper-functions-adapting-code",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html#part-1-bringing-in-helper-functions-adapting-code",
    "title": "Exercise 5.8",
    "section": "Part 1: Bringing in helper functions & adapting code",
    "text": "Part 1: Bringing in helper functions & adapting code\nAs in exercise 5.7, we will need to bring in all the functions from the previous exercise.\n\n\n\n\n\n\nTip\n\n\n\nThese functions can also be called “helper functions”. Helper functions are smaller functions that are used together to complete bigger functions. Helper functions make code improve code readability and make it easier to reuse code, like we’re doing in this exercise.\n\n\nWe will also need to alter the resultsNP1 (and rename it) along with the simulations function to include a third treatment. While these changes will have a big impact on our analyses, they are relatively small changed programmatially because the logic has already been built.\n\ndrawBetaMethodMoments &lt;- function(n,mu,s){\n  \n  #functions estimates alpha and beta using the method of moments then draws from the beta distribution\n  alpha &lt;- ((mu*(1-mu)/s^2) -1)*mu\n  beta &lt;- alpha*(1-mu )/mu\n  \n  #draw our random number\n  draw &lt;- rbeta(n,alpha,beta)\n  \n  return(draw)\n  \n}\n\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n   \n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n   \n}\n\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n  return(tProbs)\n  \n}\n\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;- iVec %*% tProbs \n    \n    #update iVec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  return(matReturn)\n  \n}\n\nNext we alter the analysis and simulation functions to add the third prosthesis. We will omit the NP1Inc variable from exercise 5.7, as it is redundant.\n\nanalysisNP2 &lt;- function(omrPTHR,omrRTHR,mr,rrr,rrNP1,rrNP2,cPrimary,cRevision,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){\n\n    #calculate the revision risk\n   rr &lt;- tProbsHazard(t=t,lambda = lambda,gamma = gamma)\n   mr &lt;- sapply(1:t,function(x){\n    \n    #calculate which index select based on the age group\n    inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n    \n    #select the gender columns\n    #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n    genderCol &lt;- ifelse(male ==1,3,4)\n    \n    return(yearlyTProbs[inds,genderCol])\n    \n  })\n    \n  #calculate standard states\n  standPopStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)\n  lifeYearsStandard &lt;- rowSums(standPopStates[,-5])\n  #excludes death year\n  costVec &lt;- c(0,0,cRevision,0)\n\n  #add a parameter for the initial cost we had 1000 initial patients\n  iCostStandard &lt;- cStandard*1000\n  \n  #first calculate the total cost\n  totalCosts &lt;- standPopStates[,-5] %*% costVec\n  \n  #calculate the discounted cost\n  discCostStandard &lt;- discountFormula(totalCosts,cDR,t=t)\n  \n  #calculate the quality adjusted life years by creating a vector for each state utility except death\n  utility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n  \n  #multiply by the cohort\n  totalQuality &lt;- standPopStates[,-5] %*% utility\n  QALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  STDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\n  STDLYs &lt;- sum(lifeYearsStandard)/1000\n  STDQALYS &lt;- sum(QALYStandard)/1000\n\n  \n  ###repeat this for the NP1###\n  rrNP1_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np1\n  lifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n  \n  #total and discounted costs\n  totalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costVec\n  discCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t=t)\n  #add the initial cost for NP1\n  iCostNP1 &lt;- cNP1*1000\n  #Utility\n  totalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\n  QALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\n  NP1LYs &lt;- sum(lifeYearsNP1)/1000\n  NP1QALYS &lt;- sum(QALYNP1)/1000\n  \n  #####################################\n  #                                   #\n  #   Add the NP2 analysis here       # \n  #                                   # \n  #####################################\n  rrNP2_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP2,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP2 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP2_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np2\n  lifeYearsNP2 &lt;- rowSums(populationStatesNP2[,-5])\n  \n  #total and discounted costs\n  totalCostsNP2 &lt;- populationStatesNP2[,-5] %*% costVec\n  discCostsNP2 &lt;- discountFormula(totalCostsNP2,cDR,t=t)\n  #add the initial cost for NP2\n  iCostNP2 &lt;- cNP2*1000\n  #Utility\n  totalQualityNP2 &lt;- populationStatesNP2[,-5] %*% utility\n  QALYNP2 &lt;- discountFormula(totalQualityNP2,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP2cost &lt;- sum(c(iCostNP2,discCostsNP2))/1000\n  NP2LYs &lt;- sum(lifeYearsNP2)/1000\n  NP2QALYS &lt;- sum(QALYNP2)/1000\n\n  #returns a list of discounted cost and QALYs for each method\n  return(list(STDcost = STDcost, STDQALYS = STDQALYS, NP1cost = NP1cost,NP1QALYS = NP1QALYS,\n              NP2cost = NP2cost, NP2QALYS = NP2QALYS ))\n  \n}\n\nNext we will change the simulation function to store the results of the NP2 analysis\n\ngenerateSimulations &lt;- function(nReps = 1000,age=60,male=0,cRatio = 100000){\n   \n   cols &lt;- c(\"omrPTHR\",\"omrRTHR\",\"rrNP1\",\"rrNP2\",\"rrr\",\"lambda\",\"gamma\",\"cPrimary\",\"cRevision\",\"cSuccess\",\"uSuccessP\",\"uSuccessR\",\"uRevision\",\n                          \"cRatio\",\"STDCost\",\"STDQALYS\",\"NP1Cost\",\"NP1QALYS\",\"NP2Cost\",\"NP2QALYS\",\"STDNMB\",\"NP1NMB\",\"NP2NMB\",\"CESTD\",\"CENP1\",\"CINP2\")\n   \n   #we need to know how many columns or variable we have here in ncol\n   dfReturn &lt;- data.frame(matrix(NA,nrow = nReps,ncol = length(cols)))\n  \n   #fill out the column names for our dataframe\n   colnames(dfReturn) &lt;- cols\n  \n  \n   #cRatio is fixed at 100000\n   dfReturn$cRatio &lt;- cRatio\n   alpha &lt;- (5294/1487)^2\n   beta &lt;- 1487^2 / 5294\n   \n   \n   #due to R's vectorization, we can sample all the parameters at once in the \"n\" parameter\n   omrPTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following primary THR\n   omrRTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following revision THR\n   rrr &lt;- rbeta(nReps,4,96) #re-revision risk\n   \n   #save them here using R's vectorization\n   dfReturn$omrPTHR &lt;- omrPTHR\n   dfReturn$omrRTHR &lt;- omrRTHR \n   dfReturn$rrr &lt;- rrr\n   \n   #cost and utility\n   cRevision &lt;- rgamma(nReps,shape = alpha,scale = beta)\n   uSuccessP &lt;- drawBetaMethodMoments(nReps,0.85,0.03)\n   uSuccessR &lt;- drawBetaMethodMoments(nReps,0.75,0.04)\n   uRevision &lt;- drawBetaMethodMoments(nReps,0.3,0.03)\n   \n   dfReturn$cRevision &lt;- cRevision\n   dfReturn$uSuccessP &lt;- uSuccessP\n   dfReturn$uSuccessR &lt;- uSuccessR\n   dfReturn$uRevision &lt;- uRevision \n   \n   #draw from multivariate normal\n   normDraw &lt;- MASS::mvrnorm(nReps, mu = survModelSummary$coefficient, Sigma = covMat)\n   \n   #using R's vectorization, we can calculate operations on the entire vector, we must use [,\"name\"]as normDraw is not a matrix rather than a vector\n   lambda &lt;- exp(normDraw[,'cons'] + normDraw[,'age']*age + normDraw[,'male']*male)\n   gamma &lt;- exp(normDraw[,'lngamma'])\n   rrNP1 &lt;- exp(normDraw[,'NP1'])\n   rrNP2 &lt;- exp(normDraw[,'NP2'])\n   \n   dfReturn$lambda &lt;- lambda\n   dfReturn$gamma &lt;- gamma\n   dfReturn$rrNP1 &lt;- rrNP1\n   dfReturn$rrNP2 &lt;- rrNP2\n\n  #start the for-loop\n  \n  for(i in 1:nReps){\n     \n    results &lt;- analysisNP2(dfReturn$omrPTHR[i],dfReturn$omrRTHR[i],mr,dfReturn$rrr[i],dfReturn$rrNP1[i], dfReturn$rrNP2[i],\n                           dfReturn$cPrimary[i],dfReturn$cRevision[i],dfReturn$cStandard[i],dfReturn$uSuccessP[i],\n                           dfReturn$uSuccessR[i],dfReturn$uRevision[i],cDR,oDR,cNP1,dfReturn$gamma[i],dfReturn$lambda[i],\n                           iVec,t)\n    \n    \n    #save the results, including NP2\n    dfReturn$STDCost[i] &lt;- results$STDcost\n    dfReturn$STDQALYS[i] &lt;- results$STDQALYS\n    dfReturn$NP1Cost[i] &lt;- results$NP1cost\n    dfReturn$NP1QALYS[i] &lt;- results$NP1QALYS\n    dfReturn$NP2Cost[i] &lt;- results$NP2cost\n    dfReturn$NP2QALYS[i] &lt;- results$NP2QALYS\n    \n    \n    #calculate net monetary benefit, we now remove the redundant  \"NP1 inc\"\n    dfReturn$STDNMB[i] &lt;- results$STDQALYS*dfReturn$cRatio[i]-results$STDcost\n    dfReturn$NP1NMB[i] &lt;- results$NP1QALYS*dfReturn$cRatio[i]-results$NP1cost\n    dfReturn$NP2NMB[i] &lt;- results$NP2QALYS*dfReturn$cRatio[i]-results$NP2cost    \n    #calculate the cost effectiveness. Note with 3 methods, we must take the maximum \n    bestTreatment &lt;- max(dfReturn$STDNMB[i], dfReturn$NP1NMB[i], dfReturn$NP2NMB[i])\n   \n    #save the cost effectiveness winner\n    dfReturn$CESTD[i] &lt;- ifelse(dfReturn$STDNMB[i]==bestTreatment,1,0)\n    dfReturn$CENP1[i] &lt;- ifelse(dfReturn$NP1NMB[i]==bestTreatment,1,0)\n    dfReturn$CENP2[i] &lt;- ifelse(dfReturn$NP2NMB[i]==bestTreatment,1,0)\n\n  }\n  \n  return(dfReturn)\n}",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html#part-2-running-the-simulations",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html#part-2-running-the-simulations",
    "title": "Exercise 5.8",
    "section": "Part 2: Running the simulations",
    "text": "Part 2: Running the simulations\nWe will run the simulations with the new prosthesis treatment and calculate a probabilistic ICER for each treatment. Then we will plot the cost-effectiveness plane for each of the treatments using all simulation points.\nWe start by setting our seed and then calling our generateSimulations function.\n\nset.seed(12345)\n\nsimResults &lt;- generateSimulations(nReps = 1000,age=60,male=0,cRatio = 100000)\n\nWe can easily calculate means using colMeans\n\nmeanResults &lt;- colMeans(simResults[,c(\"STDCost\",\"STDQALYS\",\"NP1Cost\",\"NP1QALYS\",\"NP2Cost\",\"NP2QALYS\")])\n\nThen, we calculate the ICER for each treatment comparison.\n\nICER_NP2vNP1 &lt;- (meanResults[\"NP2Cost\"]-meanResults[\"NP1Cost\"])/( meanResults[\"NP2QALYS\"]- meanResults[\"NP1QALYS\"])\n\nICER_NP2vNP1\n\n NP2Cost \n49850.39 \n\nICER_NP2vSTD &lt;- (meanResults[\"NP2Cost\"]-meanResults[\"STDCost\"])/( meanResults[\"NP2QALYS\"]- meanResults[\"STDQALYS\"])\n\nICER_NP2vSTD\n\n NP2Cost \n14322.57 \n\nICER_NP1vSTD &lt;- (meanResults[\"NP1Cost\"]-meanResults[\"STDCost\"])/( meanResults[\"NP1QALYS\"]- meanResults[\"STDQALYS\"])\n\nICER_NP1vSTD\n\n NP1Cost \n11097.74 \n\n\nWe will plot the cost and QALYS for each intervention.\nNote since we have 3 response variables we want to plot, we must transform the data into “long format”. The easiest way to do this is to use the dplyr and tidyr packages for data manipulation. We are also using the viridis package for color theming. If you don’t have these installed, you can install them using install.packages(\"dplyr\", \"tidyr\", \"viridis\"). You should have installed ggplot2 when completing exercise 5.7.\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:MASS':\n\n    select\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(viridis)\n\nLoading required package: viridisLite\n\n\nThe code below requires additional knowledge of dplyr, tidyr, and regex and a bit of knowledge of pipes ‘%&gt;%’.\n\n\n\n\n\n\nTip\n\n\n\nYou will use these packages a lot so it is worth taking the time to learn some of their key functions\n\ndplyr cheat sheet: https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf\ntidyr cheat sheet: https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf\nYou can learn more about regex (regular expressions) here: https://www.datacamp.com/tutorial/regex-r-regular-expressions-guide\n\n\n\n\nsimResultsLong &lt;- simResults %&gt;% dplyr::select(STDCost:NP2QALYS) %&gt;% tidyr::pivot_longer(STDCost:NP2QALYS,names_to = c(\"treatment\",\".value\"),  names_pattern = \"([A-Z 0-9]+)(Cost|QALYS)\")\n\nFinally, we plot the results of each treatment.\n\nggplot2::ggplot(simResultsLong, \n                aes(\n                  x = QALYS,\n                  y = Cost, \n                  colour = treatment)) + \n                geom_point() + \n                viridis::scale_colour_viridis(\n                  discrete = TRUE,  # categorical variable\n                  option = \"D\"      # viridis palette option\n                ) +\n                theme_minimal() + \n                labs(title = \"Cost effectiveness plane for each treatment\")",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html#part-3-vary-the-threshold-ratio",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch5-Exercise-58.html#part-3-vary-the-threshold-ratio",
    "title": "Exercise 5.8",
    "section": "Part 3: Vary the threshold ratio",
    "text": "Part 3: Vary the threshold ratio\nRun the analysis while varying the ceiling or threshold ratio cRatio to plot the treatments with the highest net monetary benefits. Much of the code structure comes from exercise 5.7.\n\n# create a sequence of cRatios\ncRatios &lt;- seq(0,100000,by = 2500)\n\nTake the sapply structure directly from the previous exercise and make alterations to calculate the ratio for every treatment.\nAgain by default, when returning a vector (propCE), it defaults to a column vector which is stacked row-wise. We can use t() to transform into row vectors\n\ncRatioResults &lt;- t(sapply(cRatios,function(x){\n  \n  #call the simulation\n  allSimResults &lt;- generateSimulations(nReps = 1000,cRatio = x)\n  \n  #calculate the proportion for each simulation\n  propCE &lt;- colMeans(allSimResults[,c(\"CESTD\",\"CENP1\",\"CENP2\")])\n  \n  return(propCE)\n  \n}))\n\nTurn the matrix into a dataframe and add the cRatio vector.\n\ncRatioResults &lt;- as.data.frame(cRatioResults)\ncRatioResults$cRatio &lt;- cRatios\n\nJust as in the previous section, we need to transform the dataframe from wide to long format.\n\nCEAcurveLong &lt;- cRatioResults %&gt;% tidyr::pivot_longer(CESTD:CENP2,names_to = \"treatment\", values_to = \"propCI\")\n\nAgain, as a final step we will plot these results using ggplot2\n\nggplot2::ggplot(CEAcurveLong,\n                aes(\n                  x = cRatio, \n                  y = propCI, \n                  colour = treatment)) + \n                geom_line(\n                  linewidth = 1.2) + \n                viridis::scale_colour_viridis(\n                  discrete = TRUE,   # categorical variable\n                  option = \"D\"       # choose one of the viridis palettes\n                ) +\n                theme_minimal() + \n                labs(\n                  x = \"Ceiling Ratio\", \n                  y = \"Proportion of treatment cost effective\", \n                  title = \"Cost effective analysis curves for three prosthesis treatments\")",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 5.8"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html",
    "title": "Exercise 6.6A & 6.6B",
    "section": "",
    "text": "Setup\nThis section reproduces exercise 6.6a and 6.6b in R from Chapter 6 in the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton.\n#Exercise 6.6A\nMuch of the code will come from exercise 5.8. In this exercise, we will use the simulation results to calculate the expected value of perfect information (EVPI). In this first code chunk we bring over all the previous functions that generated the cost effectiveness data for each of the prosthesis interventions considered in exercise 5.8.\nIn this case, we are only focusing on the standard prosthesis and the “new prosthesis” NP1. So the values for NP2 will ignored for now.\nlibrary(MASS)\n\n##fixed parameters##\n\ncStandard &lt;- 394 #cost of standard prosthesis\ncNP1 &lt;- 579 #cost of new prosthesis 1\n\ncDR &lt;- 0.06 #cost discount rate\noDR &lt;- 0.015 #outcome discount rate\nage &lt;- 60 #average age of all patients at receipt of primary implant\nmale &lt;- 0 #sex indicator (0 for female, 1 for male)\n\niVec &lt;- c(1000,0,0,0,0) #starting vector; everyone starts in the first state\nt &lt;- 60 #number of cycles\n\ncovMat &lt;- matrix(\n  c(0.0022515  , -0.005691 ,  0.000000028,  0.0000051,  0.000259 ,\n   -0.005691   ,  0.0432191, -0.000783   , -0.007247 , -0.000642 ,\n    0.000000028, -0.000783 ,  2.716e-05  ,  0.000033 , -0.000111 ,\n    0.0000051  , -0.007247 ,  0.000033   ,  0.0118954,  0.000184 ,\n    0.000259   , -0.000642 , -0.000111   ,  0.000184 ,  0.1463686\n   ),\n  nrow = 5, ncol = 5, byrow = T\n)\n\ncolnames(covMat) &lt;- rownames(covMat) &lt;- c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\")\n\nsurvModelSummary &lt;- data.frame(\n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\n\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n#if we need cholesky decomposition\ncholcovMat &lt;- chol(covMat)\n\n#fixed mortality rates and transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n)\n\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\nNow we will bring in all the previous functions relevant to the NP1 analysis.\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\ndrawBetaMethodMoments &lt;- function(n,mu,s){\n  \n  #functions estimates alpha and beta using the method of moments then draws from the beta distribution\n  alpha &lt;- ((mu*(1-mu)/s^2) -1)*mu\n  beta &lt;- alpha*(1-mu )/mu\n  \n  #draw our random number\n  draw &lt;- rbeta(n,alpha,beta)\n  \n  return(draw)\n  \n}\n\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n  \n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n  \n}\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n  return(tProbs)\n  \n}\n\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs #round because we are using full population units\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  return(matReturn)\n  \n}\n\nanalysisNP1 &lt;- function(omrPTHR,omrRTHR,mr,rrr,rrNP1,cPrimary,cRevision,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){\n\n    #calculate the revision risk\n   rr &lt;- tProbsHazard(t=t,lambda = lambda,gamma = gamma)\n    \n   mr &lt;- sapply(1:t,function(x){\n    \n    #calculate which index select based on the age group\n    inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n    \n    #select the gender columns\n    #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n    genderCol &lt;- ifelse(male ==1,3,4)\n    \n    return(yearlyTProbs[inds,genderCol])\n    \n  })\n    \n  #calculate standard states\n  standPopStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)\n  lifeYearsStandard &lt;- rowSums(standPopStates[,-5])\n  #excludes death year\n  costVec &lt;- c(0,0,cRevision,0)\n\n  #add a parameter for the initial cost we had 1000 initial patients\n  iCostStandard &lt;- cStandard*1000\n  \n  #first calculate the total cost\n  totalCosts &lt;- standPopStates[,-5] %*% costVec\n  \n  #calculate the discounted cost\n  discCostStandard &lt;- discountFormula(totalCosts,cDR,t=t)\n  \n  #calculate the quality adjusted life years by creating a vector for each state utility except death\n  utility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n  \n  #multiply by the cohort\n  totalQuality &lt;- standPopStates[,-5] %*% utility\n  QALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  STDCost &lt;- sum(c(iCostStandard,discCostStandard))/1000\n  STDLYs &lt;- sum(lifeYearsStandard)/1000\n  STDQALYS &lt;- sum(QALYStandard)/1000\n\n  ###repeat this for the NP1###\n  rrNP1_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np1\n  lifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n  \n  #total and discounted costs\n  totalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costVec\n  discCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t=t)\n  #add the initial cost for NP1\n  iCostNP1 &lt;- cNP1*1000\n  #Utility\n  totalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\n  QALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP1Cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\n  NP1LYs &lt;- sum(lifeYearsNP1)/1000\n  NP1QALYS &lt;- sum(QALYNP1)/1000\n  \n  #returns a list of discounted cost and QALYs for each method\n  return(list(STDCost = STDCost, STDQALYS = STDQALYS, NP1Cost = NP1Cost,NP1QALYS = NP1QALYS, ICER = (NP1Cost-STDCost)/(NP1QALYS-STDQALYS)))\n  \n}\n\n#generate simulation function\ngenerateSimulations &lt;- function(nReps = 1000,age=60,male=0,cRatio = 100000){\n   \n   #we need to know how many columns or variable we have here in ncol\n   cols &lt;- c(\"omrPTHR\",\"omrRTHR\",\"rrNP1\",\"rrr\",\"lambda\",\"gamma\",\n             \"cPrimary\",\"cRevision\",\"cSuccess\",\"uSuccessP\",\"uSuccessR\",\n             \"uRevision\",\"cRatio\",\"STDCost\",\"STDQALYS\",\"NP1Cost\",\"NP1QALYS\",\n             \"STDNMB\",\"NP1NMB\",\"NP1Inc\",\"CESTD\",\"CENP1\",\"CENP1Inc\")\n   \n   #initialize our return dataframe\n   dfReturn &lt;- data.frame(matrix(NA, nrow = nReps, ncol = length(cols)))\n  \n   #fill out the column names for our dataframe\n   colnames(dfReturn) &lt;- cols\n\n   #cRatio is fixed at 10000\n   dfReturn$cRatio &lt;- cRatio\n   alpha &lt;- (5294/1487)^2\n   beta &lt;- 1487^2 / 5294\n   \n   \n   #due to R's vectorization, we can sample all the parameters at once in the \"n\" parameter\n   omrPTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following primary THR\n   omrRTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following revision THR\n   rrr &lt;- rbeta(nReps,4,96) #re-revision risk\n   \n   #save them here using R's vectorization\n   dfReturn$omrPTHR &lt;- omrPTHR\n   dfReturn$omrRTHR &lt;- omrRTHR \n   dfReturn$rrr &lt;- rrr\n   \n   #cost and utility\n   cRevision &lt;- rgamma(nReps,shape = alpha,scale = beta)\n   uSuccessP &lt;- drawBetaMethodMoments(nReps,0.85,0.03)\n   uSuccessR &lt;- drawBetaMethodMoments(nReps,0.75,0.04)\n   uRevision &lt;- drawBetaMethodMoments(nReps,0.3,0.03)\n   \n   dfReturn$cRevision &lt;- cRevision\n   dfReturn$uSuccessP &lt;- uSuccessP\n   dfReturn$uSuccessR &lt;- uSuccessR\n   dfReturn$uRevision &lt;- uRevision \n   \n   #draw from multivariate normal\n   normDraw &lt;- MASS::mvrnorm(nReps, mu = survModelSummary$coefficient,Sigma = covMat)\n   \n   #using R's vectorization, we can calculate operations on the entire vector, we must use [,\"name\"]as normDraw is not a matrix rather than a vector\n   lambda &lt;- exp(normDraw[,'cons'] + normDraw[,'age']*age + normDraw[,'male']*male)\n   gamma &lt;- exp(normDraw[,'lngamma'])\n   rrNP1 &lt;- exp(normDraw[,'NP1'])\n   \n   dfReturn$lambda &lt;- lambda\n   dfReturn$gamma &lt;- gamma\n   dfReturn$rrNP1 &lt;- rrNP1\n\n  #start the for-loop\n  \n  for(i in 1:nReps){\n    \n    #call the analysis function and specify the iteration for the parameter to be selected\n    #those with a parameter that is constant do not need to be called from dfReturn\n    results &lt;- analysisNP1(dfReturn$omrPTHR[i],dfReturn$omrRTHR[i],mr,dfReturn$rrr[i],dfReturn$rrNP1[i],cPrimary,dfReturn$cRevision[i],cStandard,dfReturn$uSuccessP[i],dfReturn$uSuccessR[i],dfReturn$uRevision[i],cDR,oDR,cNP1,dfReturn$gamma[i],dfReturn$lambda[i],iVec,t)\n    \n    #save the results\n    dfReturn$STDCost[i] &lt;- results$STDCost\n    dfReturn$STDQALYS[i] &lt;- results$STDQALYS\n    dfReturn$NP1Cost[i] &lt;- results$NP1Cost\n    dfReturn$NP1QALYS[i] &lt;- results$NP1QALYS\n    \n    #calculate net monetary benefit\n    dfReturn$STDNMB[i] &lt;- results$STDQALYS*dfReturn$cRatio[i]-results$STDCost\n    dfReturn$NP1NMB[i] &lt;- results$NP1QALYS*dfReturn$cRatio[i]-results$NP1Cost\n    dfReturn$NP1Inc[i] &lt;- (results$NP1QALYS-results$STDQALYS)*dfReturn$cRatio[i] - (results$NP1Cost-results$STDCost)\n    \n    #calculate the cost effectiveness\n    dfReturn$CESTD[i] &lt;- ifelse(dfReturn$STDNMB[i]&gt;= dfReturn$NP1NMB[i],1,0)\n    dfReturn$CENP1[i] &lt;- ifelse(dfReturn$CESTD[i]==1,0,1)\n    dfReturn$CENP1Inc[i] &lt;- ifelse(dfReturn$NP1Inc[i]&gt;0,1,0)\n    \n    #the above formulae come directly from the textbook 5.1.4\n  }\n   \n  return(dfReturn)\n   \n}",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 6.6A & 6.6B"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-1-calculating-net-monetary-benefit",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-1-calculating-net-monetary-benefit",
    "title": "Exercise 6.6A & 6.6B",
    "section": "Part 1: Calculating net monetary benefit",
    "text": "Part 1: Calculating net monetary benefit\nWe will start the simulation the way as in Exercise 5.7 and 5.8. Then we will calculate the mean net monetary benefit for the standard and NP1 treatment; the maximum net monetary benefit; and the maximum net monetary benefit under perfect information.\nNet monetary benefit is often referred to as NMB. We use this initialism in the R code below.\n\nset.seed(123)\ncRatio &lt;- 100000\n\nsimResults &lt;- generateSimulations(nReps = 10000,cRatio = cRatio)\n\nWe will calculate the mean and and maximum net monetary benefit\n\n#simplest using colMeans\nmeanNMB &lt;- colMeans(simResults[,c(\"STDNMB\",\"NP1NMB\")])\n\n#get the maximum NMB within each treatment iteration\nmaxPINMB &lt;- pmax(simResults[,c(\"STDNMB\")],simResults[,c(\"NP1NMB\")])\n\nNow we can calculate the EVPI which is \\[\nE_{\\theta} [\\max_j \\text{NMB}(j,\\theta)]- \\max_j E_{\\theta}[\\text{NMB}(j,\\theta)].\n\\] For this exercise, we only need the STD and NP1 columns.\n\nEVPI &lt;- mean(maxPINMB)-max(meanNMB) \n\nEVPI \n\n[1] 0.2315862\n\n\nThis is the expected value of information for a given patient.",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 6.6A & 6.6B"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-2-calculating-the-evpi-at-the-population-level",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-2-calculating-the-evpi-at-the-population-level",
    "title": "Exercise 6.6A & 6.6B",
    "section": "Part 2: Calculating the EVPI at the population level",
    "text": "Part 2: Calculating the EVPI at the population level\nNext, we aim to calculate the EVPI at the population level by multiplying by the population, applying discounting for future years.\n\nannualPop &lt;- 40000\n\n#discounted population\ndiscPop &lt;- discountFormula(annualPop,cDR,9)\n\nNow we calculate the sum of the population years and multiply the result by the per person EVPI to get the population-level EVPI, here labeled popEVPI.\n\nperAnnumEffPop &lt;- sum(c(annualPop,discPop))\n\npopEVPI &lt;- EVPI*perAnnumEffPop\n\npopEVPI \n\n[1] 72270.58",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 6.6A & 6.6B"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-3-plotting-evpi",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-3-plotting-evpi",
    "title": "Exercise 6.6A & 6.6B",
    "section": "Part 3: Plotting EVPI",
    "text": "Part 3: Plotting EVPI\nWe will visualize our results by plotting the EVPI by the cost-effectiveness threshold ratio cRatio.\nHere we run the simulation loop by sequencing through cRatio to plot the curve. We may use the sapply family of functions.\n\nlibrary(ggplot2)\n#calculate the cRatios to be looped over\ncRatios &lt;- seq(0,50000,by = 500)\n\n#using the same sapply function as before\ncRatioResults &lt;- sapply(cRatios,function(x){\n  \n  #call the simulation\n  NP1sim &lt;- generateSimulations(nReps = 1000,cRatio = x)\n  \n  #simplest using colMeans\n  meanNMB &lt;- colMeans(NP1sim[,c(\"STDNMB\",\"NP1NMB\")])\n  #get the maximum NMB within each treatment iteration\n  maxPINMB &lt;- pmax(NP1sim[,c(\"STDNMB\")],NP1sim[,c(\"NP1NMB\")])\n  \n  EVPI &lt;- mean(maxPINMB)-max(meanNMB) \n    \n  #multiply EVPI by discounted population\n  popEVPI &lt;- EVPI*perAnnumEffPop\n\n  return(popEVPI)\n})\n\nNow, we compile our results in a data frame\n\ndfEVPI &lt;- data.frame(cRatio = cRatios, EVPI = cRatioResults)\n\nLastly, we plot the population EVPI by the cRatio using ggplot2\n\n#load package\nlibrary(\"ggplot2\")\n\n#specify plot \nggplot2::ggplot(dfEVPI,\n                aes(\n                  x = cRatio, \n                  y = EVPI)) + \n                geom_line(\n                  colour = \"#414487\",\n                  linewidth = 1.5) + \n                labs(\n                  x = \"Ceiling Ratio\",\n                  y = \"Population EVPI\", \n                  title = \"EVPI by cRatio\")",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 6.6A & 6.6B"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-1-calculating-the-expected-value-of-perfect-information-for-parameters-evppi",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-1-calculating-the-expected-value-of-perfect-information-for-parameters-evppi",
    "title": "Exercise 6.6A & 6.6B",
    "section": "Part 1: Calculating the expected value of perfect information for parameters (EVPPI)",
    "text": "Part 1: Calculating the expected value of perfect information for parameters (EVPPI)\nRecall that the Expected Value of Perfect information for Parameters (EVPPI) for some parameter \\(\\phi\\), where \\(\\theta = \\phi \\cup \\psi\\) is\n\\[\nE_\\phi\\max_j[E_{\\psi|\\phi}[NMB(j,\\phi,\\psi)]- \\max_j E_{\\theta}[\\text{NMB}(j,\\theta)].\n\\] First, if we wanted to use the results from our simulation above, we could use the which.max function to select the element from cRatios that corresponds to the largest value in the cRatioResults we calculated in 6.6A.\n\ncRatios[which.max(cRatioResults)]\n\n[1] 2500\n\n\nWhile, the textbook states 2200, due to variability in the simulations, a larger number of repetitions and finer grid of cRatios would better approximate the maximum.\nDespite this, we will use the textbook value of 2200.\n\ncRatio &lt;- 2200\n\nWe can capture the value of information for a certain parameter by fixing that parameter before the simulation. To make these changes, we must make some alterations to the generateSimulations function.\nThe main alteration is by adding a keepFixed argument. Here, keepFixed determines which parameters are held constant in the simulation. For the fixed parameter, the first element [1] is used as the “fixed” value. All other parameters not chosen by keepFixed vary as before through draws from distributions.\n\ngenerateSimulationsParam &lt;- function(nReps = 1000,age=60,male=0,cRatio = 100000, keepFixed = \"rrNP1\"){\n   \n   #we need to know how many columns or variable we have here in ncol\n   cols &lt;- c(\"omrPTHR\",\"omrRTHR\",\"rrNP1\",\"rrr\",\"lambda\",\"gamma\",\n             \"cPrimary\",\"cRevision\",\"cSuccess\",\"uSuccessP\",\"uSuccessR\",\n             \"uRevision\",\"cRatio\",\"STDCost\",\"STDQALYS\",\"NP1Cost\",\"NP1QALYS\",\n             \"STDNMB\",\"NP1NMB\",\"NP1Inc\",\"CESTD\",\"CENP1\",\"CENP1Inc\")\n   \n   #initialize our return dataframe\n   dfReturn &lt;- data.frame(matrix(NA, nrow = nReps, ncol = length(cols)))\n  \n   #fill out the column names for our dataframe\n   colnames(dfReturn) &lt;- cols\n   \n   \n   #cRatio is fixed at 10000\n   dfReturn$cRatio &lt;- cRatio\n   alpha &lt;- (5294/1487)^2\n   beta &lt;- 1487^2 / 5294\n   \n   \n   #due to R's vectorization, we can sample all the parameters at once in the \"n\" parameter\n   omrPTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following primary THR\n   omrRTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following revision THR\n   rrr &lt;- rbeta(nReps,4,96) #re-revision risk\n   \n   #save them here using R's vectorization\n   dfReturn$omrPTHR &lt;- omrPTHR\n   dfReturn$omrRTHR &lt;- omrRTHR \n   dfReturn$rrr &lt;- rrr\n   \n   #cost and utility\n   cRevision &lt;- rgamma(nReps,shape = alpha,scale = beta)\n   uSuccessP &lt;- drawBetaMethodMoments(nReps,0.85,0.03)\n   uSuccessR &lt;- drawBetaMethodMoments(nReps,0.75,0.04)\n   uRevision &lt;- drawBetaMethodMoments(nReps,0.3,0.03)\n   \n   dfReturn$cRevision &lt;- cRevision\n   dfReturn$uSuccessP &lt;- uSuccessP\n   dfReturn$uSuccessR &lt;- uSuccessR\n   dfReturn$uRevision &lt;- uRevision \n   \n   #draw from multivariate normal\n   normDraw &lt;- MASS::mvrnorm(nReps, mu = survModelSummary$coefficient,Sigma = covMat)\n   \n   #using R's vectorization, we can calculate operations on the entire vector, we must use [,\"name\"]as normDraw is not a matrix rather than a vector\n   lambda &lt;- exp(normDraw[,'cons'] + normDraw[,'age']*age + normDraw[,'male']*male)\n   gamma &lt;- exp(normDraw[,'lngamma'])\n   rrNP1 &lt;- exp(normDraw[,'NP1'])\n   \n   dfReturn$lambda &lt;- lambda\n   dfReturn$gamma &lt;- gamma\n   dfReturn$rrNP1 &lt;- rrNP1\n\n  #start the for-loop\n    \n    #choose which parameter will be kept fixed based on the first draw\n    if(keepFixed == \"rrNP1\"){\n      \n      dfReturn$rrNP1 &lt;- rrNP1[1]\n      \n    }else if(keepFixed == \"OMRs\"){\n      \n      dfReturn$omrPTHR &lt;- omrPTHR[1]\n      dfReturn$omrRTHR &lt;- omrRTHR[1]   \n      \n    }else if(keepFixed == \"cRevision\"){\n       \n      dfReturn$cRevision &lt;- cRevision[1]\n      \n    }else if(keepFixed == \"rrr\"){\n      \n        dfReturn$rrr &lt;- rrr[1]\n      \n    }else if(keepFixed == \"utilities\"){\n      \n        dfReturn$uSuccessP &lt;- uSuccessP[1]\n        dfReturn$uRevision &lt;- uRevision[1]\n        dfReturn$uSuccessR &lt;- uSuccessR[1]\n        \n    }else if(keepFixed == \"survParams\"){\n      \n        dfReturn$lambda &lt;- lambda[1]\n        dfReturn$gamma &lt;- gamma[1]\n        \n    }\n\n  for(i in 1:nReps){\n\n    results &lt;- analysisNP1(dfReturn$omrPTHR[i],dfReturn$omrRTHR[i],mr,dfReturn$rrr[i],dfReturn$rrNP1[i],cPrimary,dfReturn$cRevision[i],cStandard,dfReturn$uSuccessP[i],dfReturn$uSuccessR[i],dfReturn$uRevision[i],cDR,oDR,cNP1,dfReturn$gamma[i],dfReturn$lambda[i],iVec,t)\n    \n    #save the results, including NP2\n    dfReturn$STDCost[i] &lt;- results$STDCost\n    dfReturn$STDQALYS[i] &lt;- results$STDQALYS\n    dfReturn$NP1Cost[i] &lt;- results$NP1Cost\n    dfReturn$NP1QALYS[i] &lt;- results$NP1QALYS\n    #dfReturn$NP2Cost[i] &lt;- results$NP2cost\n    #dfReturn$NP2QALYS[i] &lt;- results$NP2QALYS\n    \n    \n    #calculate net monetary benefit, we now remove the redundant  \"NP1 inc\"\n    dfReturn$STDNMB[i] &lt;- results$STDQALYS*dfReturn$cRatio[i]-results$STDCost\n    dfReturn$NP1NMB[i] &lt;- results$NP1QALYS*dfReturn$cRatio[i]-results$NP1Cost\n    dfReturn$NP1Inc[i] &lt;- (results$NP1QALYS-results$STDQALYS)*dfReturn$cRatio[i] - (results$NP1Cost-results$STDCost)\n    \n    #dfReturn$NP2NMB[i] &lt;- results$NP2QALYS*dfReturn$cRatio[i]-results$NP2cost    \n    #calculate the cost effectiveness. Note with 3 methods, we must take the maximum \n    bestTreatment &lt;- max(dfReturn$STDNMB[i], dfReturn$NP1NMB[i], dfReturn$NP2NMB[i] )\n   \n    #save the cost effectiveness winner\n    dfReturn$CISTD[i] &lt;- ifelse(dfReturn$STDNMB[i]==bestTreatment,1,0)\n    dfReturn$CINP1[i] &lt;- ifelse(dfReturn$NP1NMB[i]==bestTreatment,1,0)\n    dfReturn$CINP1Inc[i] &lt;- ifelse(dfReturn$NP1Inc[i]&gt;0,1,0)\n    #dfReturn$CINP2[i] &lt;- ifelse(dfReturn$NP2NMB[i]==bestTreatment,1,0)\n\n  }\n  \n  return(dfReturn)\n   \n}\n\n\n#we repeat this 100 or (many times), while keeping the rrNP1 fixed\n\nfixrrNP1 &lt;- t(sapply(1:100,function(x){\n  \n  simResults &lt;- generateSimulationsParam(cRatio = 2200,keepFixed = \"rrNP1\",nReps = 1000)\n  meanBenefit &lt;- colMeans(simResults[,c(\"STDNMB\",\"NP1NMB\")])\n  \n  return(meanBenefit)\n  \n}))\n\nThen we calculate the expected maximum and adjust for the population and future discounting using the perAnnumEffPop value we calculated before.\n\n#expected maximum\nexpMaxrrNP1 &lt;- mean(pmax(fixrrNP1[,\"STDNMB\"],fixrrNP1[,\"NP1NMB\"]))\nmaxExpNP1 &lt;- max(colMeans(fixrrNP1))\n\nEVPI &lt;- expMaxrrNP1-maxExpNP1\n\n#adjust for discounting the population over time\nEVPI_pop &lt;- EVPI*perAnnumEffPop\n\nEVPI_pop\n\n[1] 3364190",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 6.6A & 6.6B"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-2-conducting-evppi-for-all-parameters",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-2-conducting-evppi-for-all-parameters",
    "title": "Exercise 6.6A & 6.6B",
    "section": "Part 2: Conducting EVPPI for all parameters",
    "text": "Part 2: Conducting EVPPI for all parameters\nNow that we have established how to perform partial value of information by fixing one parameter, we can apply this to every set of parameters.\nWe will loop through every parameter group while keeping it fixed while calculating the EVPI. Ideally we would want the number of trials and the number of repetitions to each be 1000 however this becomes quite computationally intensive. Using parallel processing would speed up this process significantly. In this section we first write the code only using sequential (base) processing but add the parallelized version in the appendix.\n\n\n\n\n\n\nTip\n\n\n\nIn the loop below, the function outerSimLoop uses the vector paramGroupsto hold all the parameter names that we want to loop through. This vector is passed as a default argument to the function, so it doesn’t need to be manually typed each time the function is called. Using a vector like this reduces the chance of typos or errors and makes the code more flexible and easier to maintain.\n\n\n\nouterSimLoop &lt;- function(trials = 100,nReps=100,cRatio=2200, paramGroups = c(\"rrNP1\",\"OMRs\",\"cRevision\",\"rrr\",\"utilities\",\"survParams\")){\n  \n  #Run the simulation for each fixed parameter\n  nParams &lt;- length(paramGroups)  \n  \n  EVPIs &lt;- data.frame(matrix(NA,nrow =1,ncol = nParams))\n  #set the column names to match our parameters of interest using paramGroups vector\n  colnames(EVPIs) &lt;- paramGroups\n\n  for(p in 1:nParams){\n    \n    fixedParam &lt;- paramGroups[p]\n    print(fixedParam )\n    \n    #call the sapply function from earlier (also referred to as the \"inner loop\" in the excel file.)\n    trialResults &lt;- t(sapply(1:trials,function(x){\n      \n      #get the simulation results\n      simResults &lt;- generateSimulationsParam(cRatio = cRatio, keepFixed = fixedParam ,nReps = nReps)\n      \n      #get the mean benefit across the trials\n      meanBenefit &lt;- colMeans(simResults[,c(\"STDNMB\",\"NP1NMB\")])\n      \n      return(meanBenefit)\n      \n    }))\n\n    #calculate the EVPI\n    expMaxrrNP1 &lt;- mean(pmax(trialResults[,\"STDNMB\"],trialResults[,\"NP1NMB\"]))\n    maxExpNP1 &lt;- max(colMeans(trialResults))\n    \n    EVPI &lt;- expMaxrrNP1-maxExpNP1\n    \n    #adjust for discounting the population over time\n    EVPI_pop &lt;- EVPI*perAnnumEffPop\n    \n    #save the EVPI\n    EVPIs[,p] &lt;- EVPI_pop\n    \n  }\n  \n  return(EVPIs)\n  \n}\n\nHere we only run the simulations of 100x100 this is already 100,000. Note that:\n\ntrials: the number of times the simulation is run for each fixed parameter (outer loop).\n\nnReps: the number of individual simulation replications within each trial (inner loop), used to estimate outcomes for that trial.\n\n\nEVPPI_simResults &lt;- outerSimLoop(trials = 100,nReps=100,cRatio=2200, paramGroups = c(\"rrNP1\",\"OMRs\",\"cRevision\",\"rrr\",\"utilities\",\"survParams\"))\n\n[1] \"rrNP1\"\n[1] \"OMRs\"\n[1] \"cRevision\"\n[1] \"rrr\"\n[1] \"utilities\"\n[1] \"survParams\"",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 6.6A & 6.6B"
    ]
  },
  {
    "objectID": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-3-ploting-the-results",
    "href": "Source/Decision-Modeling-for-Health-Economic-Evaluation/Exercises/Ch6-Exercise-66.html#part-3-ploting-the-results",
    "title": "Exercise 6.6A & 6.6B",
    "section": "Part 3: Ploting the results",
    "text": "Part 3: Ploting the results\nLastly, transform the dataframe and then plot the results of the the partial EVPI for each parameter\n\n##load tidyr package \nlibrary(tidyr)\nEVPPI_plotDF &lt;- tidyr::pivot_longer(EVPPI_simResults,everything(),names_to = \"paramGroup\",values_to = \"partialEVPI\")\n\n##load the viridis and scales package for colors and label formatting\nlibrary(viridis)\n\nLoading required package: viridisLite\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:viridis':\n\n    viridis_pal\n\nggplot2::ggplot(EVPPI_plotDF,\n       aes(\n         x = paramGroup,\n         y = partialEVPI,\n         fill = paramGroup  # fill bars by parameter group\n       )) +\n  geom_bar(\n    stat = \"identity\",\n    colour = \"grey4\"     # dark outlines for contrast\n  ) +\n  scale_fill_viridis(\n    discrete = TRUE,      # categorical variable\n    option = \"D\"          # choose a viridis palette (A-D)\n  ) +\n  scale_y_continuous(labels = comma) +  # format y-axis numbers with commas\n  labs(\n    x = \"Parameter Group\",\n    y = \"Partial EVPI\",\n    title = \"Expected value of partial perfect information by parameter group\"\n  ) +\n  theme_minimal()+\n   theme(\n    legend.position = \"none\"  # hide legend if bars are self-explanatory\n  )",
    "crumbs": [
      "Book: Decision Modelling for Health Economic Evaluation",
      "Exercise 6.6A & 6.6B"
    ]
  }
]