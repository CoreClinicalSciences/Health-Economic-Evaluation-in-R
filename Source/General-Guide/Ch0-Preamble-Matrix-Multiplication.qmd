# Preamble on R and matrix operations {.unnumbered}

This section briefly reviews common operations in R that will help make speed up the process of building writing code and markov models.

## Vectorization

One feature that makes R stand out is its built-in vectorization ability. All basic operations such as addition, subtraction, multiplication, division, exponentiation, etc all are vectorized. This means that inputting a vector to these operators outputs a vector where the function has been applied to each of the elements of the vector simultaneously.

To initialize integer vector we can use the `:` operator, where it acts as `from` `:` `to` where `from` and `to` are integers (inclusive).

### Example

```{r vectorization}
vec <- 1:10

vec
```
Now we can try some vectorized operators. 

```{r vectorized operators}
sqrt(vec)
```
or multiple operators at once

```{r vectorized operators cont}
vec + 2*sin(vec)
```

To access elements of a vector we can use the `[i]` operator, where `i` is the index of the element we want.

```{r accessing vector elements}
#create our new vector, note by default, the "-2" acts on all elements of the vector
newVec <- vec + 2*sin(vec) - exp(vec) - 2

#accessing elements
newVec[1]
newVec[5]
```

## Matrix Operations

When building markov models and building transition matrices, using matrix-vector multiplications simplifies manual computation significantly.

To multiply a matrix by a vector we must have the same number of columns in the matrix as rows in a vector. Consider below an example of a two-state markov model and the goal is to discern the proportion left in the first state after two time cycles. We also show how to select rows and columns of a matrix.

### Matrix multiplication example

First, we will create our vector called `iVec_example`. The number of entries in this vector should be the same as the number of states. In this example we will assume that everyone starts in the first state.

Note: the `c()` operation initializes a vector where we can input the values (it is considered by default a column vector)

```{r initializing a vector}
iVec_example <- c(1,0)
```

\
Below, we consider a two-state markov model. We build a 2 x 2 matrix of the transition probabilities:

```{r example markov model}
tProbs_example <- matrix(c(0.7,0.3,
                           0.1,0.9),
                 nrow = 2, ncol = 2,
                 byrow = T)
```

\
Now, we want to calculate the proportion of individuals in the first time-cycle. The results will be saved in `time1Prop`

:::{.callout-note}
Note: the number of columns in the matrix must match the number of rows in the vector.
:::

```{r example multiply matrix time 1}
time1Prop <- tProbs_example %*% iVec_example
```

\
To get the proportion after the second-time we can multiply the first-time proportion that we just calculated by the transition probability matrix

```{r example multiply matrix time 2}
time2Prop <- tProbs_example %*% time1Prop
```

\
We can use the `[i,j]` operator to extract row *i* and column *j* of a matrix. This is the same as in the vector example with the addition of the comma, to seperate the columns and rows.

```{r example extract matrix data 1}
tProbs_example[1,] #extracts the first row
tProbs_example[,2] #extracts the second column

tProbs_example[1,2] #extracts first row and second column entry
```

\
We can also use the *-i* operator to extract **all except** *i*

```{r example extract matrix data 2}
tProbs_example[-1,]  #extracts all but the 1st first row
tProbs_example[,-1]  #extracts all but the 1st column
```
