[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Decision Modelling for Health Economic Evaluation in R",
    "section": "",
    "text": "Chapter 1 - Introduction\n\n\nIntroduction\nWelcome to this online guidebook on health economic evaluation in R. This is a living resource, designed to grow and evolve over time as new examples, exercises, and methods are added. Our goal is to support learners, researchers, and practitioners in developing the skills needed to build and analyze health economic models directly in R.\nBy working in R rather than in spreadsheets alone, analysts can take advantage of a flexible, script-based environment that enhances the transparency, reproducibility, and robustness of health economic evaluation. The guide introduces key concepts step by step, with practical exercises translated from standard texts and supplemented with modern R workflows.\nThroughout, we draw on widely used packages such as dplyr and tidyr for data manipulation, ggplot2 for visualization, and tools such as MASS and MCMCpack for probability distributions and simulation. Together, these exercises and examples aim to build both technical fluency in R and a deeper understanding of best practices in health economic modelling.\n\n\nCoding style and good practices\nGood coding style is an important part of reproducible research. While individual preferences may vary, there are core elements of good practice that make code easier to read, share, and maintain. These include:\n\nUsing human-readable names for variables and functions\n\nWriting comprehensive annotations and comments\n\nBreaking code into modular, reusable functions\n\nMaintaining consistent formatting and indentation\n\nKeeping scripts organized and well-structured\n\nFor those just getting started with R, we recommend following the tidyverse style guide as a helpful reference.",
    "crumbs": [
      "Chapter 1 - Introduction"
    ]
  },
  {
    "objectID": "Chapters/1-Introduction.html",
    "href": "Chapters/1-Introduction.html",
    "title": "1  Chapter 1",
    "section": "",
    "text": "blah",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Chapter 1</span>"
    ]
  },
  {
    "objectID": "Chapters/Appendix-1-Codes.html",
    "href": "Chapters/Appendix-1-Codes.html",
    "title": "2  Appendix",
    "section": "",
    "text": "blah",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "Chapters/Ch1-Introduction.html",
    "href": "Chapters/Ch1-Introduction.html",
    "title": "Chapter 1 - Introduction",
    "section": "",
    "text": "This book reviews the exercises in “Decision Modeling for Health Economic Evaluation” by Andrew Briggs, Karl Claxton, and Mark Sculpher. We aim to re-create all the exercises, which are originally written in Excel, in R. We provide a breakdown of how to perform the analyses in R, as well, as a discussion on the advantages and dis-advantages of moving from Excel to a scripting language like R.\nWe will first start off by reviewing some basic concepts in R that may be unfamiliar to the reader, even coming from another scripting language such as python. The introduction will review R’s vectorization, matrix multiplication, and vector operations.",
    "crumbs": [
      "Introduction",
      "Chapter 1 - Introduction"
    ]
  },
  {
    "objectID": "Exercises/Ch2-Exercise-25.html",
    "href": "Exercises/Ch2-Exercise-25.html",
    "title": "Exercise 2.5",
    "section": "",
    "text": "Preamble on matrix operations\nThis R markdown file reproduces exercise 2.5 in R from Chapter 2 of the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nWhen building markov molds and building transition matrices, using matrix-vector multiplications simplifies manual computation significantly.\nTo multiply a matrix by a vector we must have the same number of columns in the matrix as rows in a vector. Consider below an example of a two-state markov model and the goal is to discern the proportion left in the first state after two time cycles. We also show how to select rows and columns of a matrix.",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Exercises/Ch2-Exercise-25.html#preamble-on-matrix-operations",
    "href": "Exercises/Ch2-Exercise-25.html#preamble-on-matrix-operations",
    "title": "Exercise 2.5",
    "section": "",
    "text": "Matrix multiplication example\nFirst, we will create our vector called iVec_example. The number of entries in this vector should be the same as the number of states. In this example we will assume that everyone starts in the first state.\nNote: the c() operation initializes a vector (it is considered by default a column vector)\n\niVec_example &lt;- c(1,0)\n\n\nBelow, we consider a two-state markov model. We build a 2 x 2 matrix of the transition probabilities:\n\ntProbs_example &lt;- matrix(c(0.7,0.3,\n                           0.1,0.9),\n                 nrow = 2, ncol = 2,\n                 byrow = T)\n\n\nNow, we want to calculate the proportion of individuals in the first time-cycle. The results will be saved in time1Prop\nNote: the number of columns in the matrix must match the number of rows in the vector.\n\ntime1Prop &lt;- tProbs_example %*% iVec_example\n\n\nTo get the proportion after the second-time we can multiply the first-time proportion that we just calculated by the transition probability matrix\n\ntime2Prop &lt;- tProbs_example %*% time1Prop\n\n\nWe can use the [i,j] operator to extract row i and column j of a matrix\n\ntProbs_example[1,] #extracts the first row\n\n[1] 0.7 0.3\n\ntProbs_example[,2] #extracts the second column\n\n[1] 0.3 0.9\n\ntProbs_example[1,2] #extracts first row and second column entry\n\n[1] 0.3\n\n\n\nWe can also use the -i operator to extract all except i\n\ntProbs_example[-1,]  #extracts all but the first row\n\n[1] 0.1 0.9\n\ntProbs_example[,-1]  #extracts all but the column\n\n[1] 0.3 0.9",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Exercises/Ch2-Exercise-25.html#start-of-exercise-2.5",
    "href": "Exercises/Ch2-Exercise-25.html#start-of-exercise-2.5",
    "title": "Exercise 2.5",
    "section": "Start of Exercise 2.5",
    "text": "Start of Exercise 2.5\nFirst, we will calculate the monotherapy transition probabilities for the control based on the data provided in Table 2.5. These probabilities should match the transition probabilities provided in Table 2.2. part 1(a)\nWe need to calculate the following transition probabilities:\n\nTransition probability from A to A\nTransition probability from A to B\nTransition probability from A to C\nTransition probability from A to D\nTransition probability from B to B\nTransition probability from B to C\nTransition probability from B to D\nTransition probability from C to C\nTransition probability from C to D\n\nPart 1\nNow that we have calculated the transition probabilities, we will use these values to populate the transition probability matrix and initialize the parameters necessary for modelling.\nThe matrix will follow the structure below, as shown in table 2.6:\n\n#         To State\n#           A B C D\n# From    A\n# State   B\n#         C\n#         D\n\n\nAs you complete the matrix, remember, that it’s not possible to go backwards in this model, so any transition probability below the diagonal values will be 0.\n\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\n#please note that there are more decimals here than in Table 2.2a and other figures. This is because we aim to maintain the exact decimals used in the Excel sheet for consistency. To get decimals closer to what we achieve here, we recommend using Table 2.5 as a guide.\n\nCheck. We will use rowSums to make sure we’ve entered our transition matrix correctly. All the rows should equal 1\n\nrowSums(tProbs) \n\n[1] 1 1 1 1\n\n\n\nNow, we will fill in other parameters that are provided in the exercise. After each parameter, we’ve used # and a description of what that parameter is so we can easily revisit our code at a future date.\n\n#costs\ndmca &lt;- 1701 #direct medical cost of A\ndmcb &lt;- 1774 #direct medical cost of B\ndmcc &lt;- 6948 #direct medical cost of C\nccca &lt;- 1055 #community care cost of A\ncccb &lt;- 1278 #community care cost of B\ncccc &lt;- 2059 #community care cost of C\ncAZT &lt;- 2278 #cost of Zidovudine\ncLam &lt;- 2086.5 #cost of Lamivudine \n\n#other parameters\nRR &lt;- 0.509 #relative risk of treatment\ncDR &lt;- 0.06 #annual discount rate cost (proportion)\noDR &lt;- 0 #annual discount rate benefits (proportion)\n\nPart 2\nNow, we will calculate the proportion of individuals in each state for years 1-20 (Monotherapy), their life-years, and associated costs.\nWe will input the initial vector for the state space, where each element refers to the initial proportion of individuals in state A-D respectively.\nWe assume all individuals start in State A. We are giving the vector the name iVec.\n\niVec &lt;-  c(1,0,0,0)\n\nWe are going to create a funcation called calculateYearlyProbs that we can use to calculate the proportion of people in each state at a given time point.\nThis function will return a t (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #Loop through all time-points and multiply the vector by \n  for(i in 1:(t)){\n\n    matReturn[i,] &lt;-   iVec %*% tProbs\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n}\n\nNow, we will call the function, by entering our transition probabilities matrix, the number of years we want to calculate, and our starting vector as arguments. We’ve called the results of our function yearlyProbs. It will return a matrix that is 20 rows (years) long and 4 states wide.\n\nyearlyProbs &lt;- calculateYearlyProbs(tProbs,20,iVec)\n\nCheck. Use rowSums to check that all rows sum to 1\n\nrowSums(yearlyProbs)\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nNow we will calculate the number of life years for each year. This is equal to the the proportion that is not in State D (death).\n\nlifeYears &lt;- rowSums(yearlyProbs[,-4])\n\nPart 3\nUsing the cost inputs from before, we will calculate the cost. Then, based on those costs, we will calculate the discounted cost using the discounted cost formula provided in the text.\nTo calculate the non-discounted costs, we will calculate a cost associated with each health state in our markov model, and then create a vector to hold the costs associated with each state.\n\ncostA &lt;- dmca+ccca+cAZT\ncostB &lt;- dmcb+cccb+cAZT\ncostC &lt;- dmcc+cccc+cAZT\n\ncostVector &lt;- c(costA,costB,costC)\n\nWe will use matrix multiplication to calculate the non-discounted cost. We will multiply yearlyProbs, the matrix holding the proportion in each health state by cycle (i.e. year), by our new costVector.\nRemember, we need to make sure the vector and the matrix have the same number of columns. So, we will use [-4] to remove the death state column from the matrix.\n\nnonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\nOur non-discounted costs are saved in nonDiscCost. To get teh discounted cost, we will apply the discounting formula. We will create a discounting function that we can reuse in the future.\nSo we can apply this function to multiple values of t at once we will use R’s vectorization. All basic operations in R “-+^/*” support basic R vectorization.\nThis means we can use the discount formula for all values of t at once (t = 1,..,20). We can do this by using 1:t in place of “t” in the formula\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\nWe can calculate the discounted costs by filling in the arguments for the newly created discount function. We need to specify: the non-discounted costs; the discount rate; and the number of years you are calculating for.\n\ndiscCost &lt;- discountFormula(nonDiscCost, discRate = cDR,20)\n\nWe will use the sum function to calculate the total costs and life years over the 20 years of the Markov model.\n\ntotalDiscCostMonoTherapy &lt;- sum(discCost)\ntotalLifeYearsMonoTherapy &lt;- sum(lifeYears)\n\nPart 4\nHaving completed the analysis for the monotherapy, we will repeat the same steps for the combination therapy, with a few changes. Use table 2.2 part 1(b) as a guide to calculate the combination transition matrix. Recall that the combination therapy is only used for the first two years of treatment.\nTo begin, lets create a function that converts the original transition matrix to the combination transition matrix by using the risk ratio provided\n\ncalculateProbCombination &lt;- function(tProbs,RR = 0.506){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\nNow, we will use our function to calculate the transition probabilities for the combination therapy:\n\ntProbsComb &lt;- calculateProbCombination(tProbs,RR = RR)\n\nCheck. Just like before, we will use rowSums to check that all rows sum to 1\n\nrowSums(tProbsComb)\n\n[1] 1 1 1 1\n\n\nThen we will calculate the yearly proportions for the first two years using the function calculateYearlyProbs that we created above. The function arguments will include tProbsComb–the new proportions matrix for the combination therapy.\n\nprobsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n\nNow we will calculate the yearly proportions for years 3-20. We will use the transition probabilities for monotherapy for these calculations, reflecting that the combination therapy is only used in years 1 and 2. We will then combined the two calculations to get the values for years 1-20, and check that each row sums to 1.\n\nprobsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = 18,iVec =probsCombYearly1_2[2,])\n\n#combine them\nprobsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n\n#check\nrowSums(probsCombYearly) # all sum to 1\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nUsing the same approach as for the monotherapy, we will calculate the life years and the costs, being careful to apply the correct costs to the correct proportions.\n\n#calculate the life-years\nlifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n\n#calculate the costs\ncostAComb &lt;- costA+cLam\ncostBComb &lt;- costB+cLam\ncostCComb &lt;- costC+cLam\n#combine the costs into a vector\ncostVectorComb &lt;- c(costAComb,costBComb,costCComb)\n\n#use matrix multiplication\ncostCombNonDisc1_2 &lt;-   probsCombYearly[1:2,-4] %*% costVectorComb\ncostCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n\nWe will use rbind to combine the non-discounted costs and then use the discount function to calculate the discounted costs. With the costs and life years calculated for each year, we will use sum to calculate the total costs and life years associated with the combination therapy.\n\n#use rbind to combine the non-discounted cost\ncostCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n\n#calculate the discounted rate\ncostCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,20)\n\n#calculate the total costs and life years for the combination therapy\ntotalLifeYearsComb &lt;- sum(lifeYearsComb)\ntotalDiscCostComb &lt;- sum(costCombDisc)\n\nPart 5\nLastly, compare the total life years and costs between the monotherapy and combination therapy to calculate the ICER\n\n#combination over monotherapy\nlifeYearsGained &lt;- totalLifeYearsComb - totalLifeYearsMonoTherapy\nincreasedCost &lt;- totalDiscCostComb - totalDiscCostMonoTherapy\n\n#calculate ICER\nICER &lt;- increasedCost/lifeYearsGained\n\nICER \n\n[1] 6275.956",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 2.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html",
    "href": "Exercises/Ch3-Exercise-35.html",
    "title": "Exercise 3.5",
    "section": "",
    "text": "Setup\nThis R markdown file reproduces exercise 3.5 in R from Chapter 3 of the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nThis exercise builds upon the skills from exercise 2.5. You will need to know how to build and call functions in R, as well as how to multiply matrices.\nThe following Markov Model will be used in this exercise. Use it to fill in the transition probabilities in the later section. This figure comes directly from the original Excel worksheet provided by Andrew Briggs, Mark Sculpher, and Karl Claxton.\nTo begin, we need to enter our parameter values. Some are are provided directly and some need to be calculated.\nBelow we enter the cost and utility parameters provided.\nmale &lt;- 0 #0 for female, 1 for male\nage &lt;- 60 #average age at receipt for primary implant\n\n#transition probabilities\n#these values are provided at the start of the guide on in section 3.5.2\nomrPTHR &lt;- 0.02 #operative mortality rate for primary THR\nomrRTHR &lt;- 0.02 #operative mortality rate for revision THR\nrrr &lt;- 0.04 #re-revision risk rate\n\n#costs\ncRevision &lt;- 5294 #cost of revisions\ncStandard &lt;- 394 #cost of standard implant\ncNP1 &lt;- 579 #cost of new implant\n\n#discount rates\ncDR &lt;- 0.06 #cost discount\noDR &lt;- 0.015 #outcome discount\n\n#utility of markov states\n#these values are given in Section 3.5.2 1) iii\nuSuccessP &lt;- 0.85 #utility of primary success\nuSuccessR &lt;- 0.75 #utility of revision success\nuRevision &lt;- 0.30 #utility of revision\nNow we will enter the survival model that is fit with a weibull distribution.\nRemember that the coefficients are on the log scale.\nsurvModelSummary &lt;- data.frame(\n  \n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nTo calculate lambda of the weibull distribution we can take the linear combination of the coefficients. Again, we need to remember to exponentiate the results as they are on the log scale.\nWe can use the $ operator to create new columns in the survModelSummary dataframe and extract any column from the dataframe by name. the $ operator by default extracts a vector, which means vector operations can be done on them such as [i] to extract the ith element of the vector. If you want to refresh your memory on how to use [i] to extract a data element, review exercise 2.5.\n#replace `columnname`\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n#use the $ operator to extract the column of choice then use [i] to extract the coeficient of choice\n#for example [2] corresponds to the constant coefficient \nlnLambda &lt;- survModelSummary$coefficient[2] + survModelSummary$coefficient[3]*age + survModelSummary$coefficient[4]*male\n\n#ensure to exponentiation lambda and gamma as they are in in the log scale\nlambda &lt;- exp(lnLambda)\ngamma &lt;- exp(survModelSummary$coefficient[1])",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-2",
    "href": "Exercises/Ch3-Exercise-35.html#step-2",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.2 Step 2",
    "text": "2.2 Step 2\nUsing life-tables for background mortality\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n#note that by default this exercise uses Female. Lets create the death risk by analyzing the cycle for those who are female and have an average age of 60 plus the cycle year due to all cause mortality\n\n#we use a special function in R called the apply family. This function takes two arguments x and a function of x. This function is then applied to all elements of x. We can use this to extract the appropriate cell of the yearlyTProbs dataset for all 60 cycles. The apply function family is essentially a wrapper of a for-loop, that can be quickly written. If you prefer the equivalent code, it can be written as a for-loop.\n\n#here we are using the sum function on a \"logical if\" for example we are on cycle 5 then the average patient age is now 5+60 which is 65, then there are 4 rows (which all show up as true or false values) that are less than or equal to 65, taking the sum gives us an index of 4 which is the appropriate index to select\ndeathRisk &lt;- sapply(1:60,function(x){\n  \n  #calculate which index select based on the age group\n  inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n  \n  #select the gender columns\n  #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n  genderCol &lt;- ifelse(male ==1,3,4)\n  \n  return(yearlyTProbs[inds,genderCol])\n  \n})",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-3",
    "href": "Exercises/Ch3-Exercise-35.html#step-3",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.3 Step 3",
    "text": "2.3 Step 3\nCreate the Markov Model. We must specify a transition matrix as in Exercise 2.5 and then calculate the number of individuals in each state for 60 cycles. The change here from Exercise 2.5 is that the transition probabilities change depending on the cycle.\nLet the use the Figure shown at the beginning of the file. Let the first column be PrimaryTHR, the second column be Success of primary THR (SuccessP), the third column be Revision THR, the fourth column be Success of Revision (SuccessR), and the fifth column be Death. Thus we have a 5 state Markov model.\n\n# The matrix will follow this structure, shown in Figure 3.7:\n# \n#                     To State\n#                       PrimaryTHR SuccessP RevisionTHR SuccessR Death\n# From    PrimaryTHR\n# State   SuccessP\n#         RevisionTHR \n#         SuccessR\n#         Death\n\n\n#note now that our transition matrix is now time-dependent, that is, depending on the cycle, the transition probability will change. Therefore we must make a function that alters the transition matrix based on the cycle. Fill in the following transition matrix function with the appropriate transition probabilities. To get the t'th value of vector such as mr, we can use the [t] operator.\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR), 0, 0, omrPTHR,\n    0, 1-(rr[t]+mr[t]) , rr[t], 0, mr[t],\n    0, 0, 0, 1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0, rrr, 1-(rrr+mr[t]), mr[t],\n    0, 0, 0, 0, 1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n}\n\n#check manually that each row sums to 1 by performing some algebra.\n\n#we must now calculate the amount of individuals in each state for 60 cycles. Re use the function created in exercise 2.5 but modify it slightly for the new markov model including the extra states and  time-dependent transition probabilities.\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs #round because we are using full population units\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a 60 (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\n\n#create our initial vector of population starts, all start in thePrimaryTHR state.\niVec &lt;- c(1000,0,0,0,0)\n\n#calculate all states for all cycles.\npopulationStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR,omrRTHR,rr= revisionRisk, mr = deathRisk,rrr=rrr,t=60)\n\n#check that the row sums are equal to 1000\nrowSums(populationStates)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-4",
    "href": "Exercises/Ch3-Exercise-35.html#step-4",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.4 Step 4",
    "text": "2.4 Step 4\nNext, adapt the model for a new prosthesis. We may reuse the previous results while adding the treatment effect.\n\n#new revision risk adjusts the lambda value by a scalar -- the hazard ratio of NP1\n#use the $ operator to extract the appropriate hazard ratio\nrrNP1 &lt;- survModelSummary$hazard_ratio[5]\n\nrevisionRiskNP1 &lt;- tProbsHazard(t=60,lambda = lambda*rrNP1,gamma = gamma)\n\n#calculate the updated states by calculateYearlyProbs function we created earlier and filling in the appropriate arguments\npopulationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=revisionRiskNP1,mr=deathRisk,rrr,t=60)\n\n#check that the row sums are equal to 1000\nrowSums(populationStatesNP1)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-5",
    "href": "Exercises/Ch3-Exercise-35.html#step-5",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.5 Step 5",
    "text": "2.5 Step 5\nCalculate the costs for both the standard and NP1 models. Import the discount formula from exercise 2.5\n\n#this formula comes directly from the previous exercise\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n#calculate Life-Years using rowSums, ensure to exclude the last state of death by using the [,-i] operator\nlifeYearsStandard &lt;-rowSums(populationStates[,-5])\n\n#create the cost vector, assume that we are removing the last state of death. The length of the vector should only then be 4, the total of the remaining states\ncosts&lt;- c(0,0,cRevision,0)\n\n#add a parameter for the initial cost. We had 1000 initial patients\niCostStandard &lt;- cStandard*1000\n\n#calculate the total cost by using matrix multiplication on our population state sets\ntotalCosts &lt;- populationStates[,-5] %*% costs\n\n\n#update the costs to account for discounting over time. Call the discount formula and fill in the appropriate arguments\ndiscCostStandard &lt;- discountFormula(totalCosts,cDR,t = 60)\n\n#next we need to repeat the previous steps for utility of the treatment over time\n#create a utility vector for each state except death\nutility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n\n#calculate the utility over time and the adjusted discounted utility, this should be a similar process as the costs\ntotalQuality &lt;-  populationStates[,-5] %*% utility\nQALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t = 60)\n\n#calculate the total cost for all cycles/person, ensure to include the initial cost of the treatment\nSTDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\nSTDLYs &lt;- sum(lifeYearsStandard)/1000\nSTDQALYS &lt;- sum(QALYStandard)/1000\n\n\n\n#####repeat for the new prosthesis (NP1)######\n#all steps should be the same for the new, with updated costs and utilities\n\n#use rowsums to get the total life years\nlifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n\n#total and discounted costs\ntotalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costs\ndiscCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t = 60)\n\n\n#add the initial cost for NP1 via cNP1\niCostNP1 &lt;- cNP1*1000\n\n\n#Utility\ntotalQualityNP1 &lt;-  populationStatesNP1[,-5] %*% utility\nQALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t = 60)\n\n#calculate the total cost for all cycles/person, ensure to add the initial cost of the new implant\nNP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\nNP1LYs &lt;- sum(lifeYearsNP1)/1000\nNP1QALYS &lt;- sum(QALYNP1)/1000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-6",
    "href": "Exercises/Ch3-Exercise-35.html#step-6",
    "title": "\n2  Exercise 3.5\n",
    "section": "\n2.6 Step 6",
    "text": "2.6 Step 6\nCalculate the ICER for the new prosthesis compared to standard care\n\n#calculate the difference in costs\ndiffCost &lt;- NP1cost-STDcost\n\n#difference in QALYs\ndiffQALY &lt;- NP1QALYS-STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 2198.487",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 3.5</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-1-calculate-the-transition-probabilities",
    "href": "Exercises/Ch3-Exercise-35.html#step-1-calculate-the-transition-probabilities",
    "title": "Exercise 3.5",
    "section": "Step 1: Calculate the transition probabilities",
    "text": "Step 1: Calculate the transition probabilities\nLets create a function to calculate the transition probabilities for a yearly cycle t. The formula is given in Section 3.5.2 Section 2 iii).\nAs we noted above, R is vectorized. That means we can input a vector as an argument and each element of the vector will be passed through.\nWe want all of t = 1,…,60 to be calculated so we can simply use 1:t which creates a vector 1,…,t\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n  \n}\n\nWe can use this function to calculate the revision risk or the time-dependent transition probability per year.\n\nrevisionRisk &lt;- tProbsHazard(60,lambda = lambda,gamma = gamma)",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-2-using-life-tables-for-background-mortality",
    "href": "Exercises/Ch3-Exercise-35.html#step-2-using-life-tables-for-background-mortality",
    "title": "Exercise 3.5",
    "section": "Step 2: Using life-tables for background mortality",
    "text": "Step 2: Using life-tables for background mortality\nWe want to make sure we are accounting for background mortality in our model. First, we will add the death rates and yearly transition probabilities provided in the exercise.\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\nNote that by default this exercise uses female. Lets create the death risk by analyzing the cycle for those who are female and have an average age of 60 plus the cycle year due to all cause mortality\nTo do this we will us use a special function in R called the apply family. This function takes two arguments x and a function of x. This function is then applied to all elements of x. We can use this to extract the appropriate cell of the yearlyTProbs dataset for all 60 cycles. The apply function family is essentially a wrapper of a for-loop, that can be quickly written. If you prefer the equivalent code, it can be written as a for-loop.\nHere we are using the sum function on a “logical if”. For example we are on cycle 5 then the average patient age is now 5+60 which is 65, then there are 4 rows (which all show up as true or false values) that are less than or equal to 65, taking the sum gives us an index of 4 which is the appropriate index to select.\n\ndeathRisk &lt;- sapply(1:60,function(x){\n  \n  #calculate which index select based on the age group\n  inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n  \n  #select the gender columns\n  #if else takes 3 arguments, the first is a logic check, if true, it returns the second value, \n  #if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n  genderCol &lt;- ifelse(male ==1,3,4)\n  \n  return(yearlyTProbs[inds,genderCol])\n  \n})",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-3-creating-the-markov-model",
    "href": "Exercises/Ch3-Exercise-35.html#step-3-creating-the-markov-model",
    "title": "Exercise 3.5",
    "section": "Step 3: Creating the Markov Model",
    "text": "Step 3: Creating the Markov Model\nTo create the Markov Model, we must specify a transition matrix as in Exercise 2.5 and then calculate the number of individuals in each state for 60 cycles. The change here from Exercise 2.5 is that the transition probabilities change depending on the cycle.\nLet’s use the Figure shown at the beginning of the file. Let the first column be PrimaryTHR, the second column be Success of primary THR (SuccessP), the third column be Revision THR, the fourth column be Success of Revision (SuccessR), and the fifth column be Death. Thus we have a 5 state Markov model.\n\n# The matrix will follow this structure, shown in Figure 3.7:\n# \n#                     To State\n#                       PrimaryTHR SuccessP RevisionTHR SuccessR Death\n# From    PrimaryTHR\n# State   SuccessP\n#         RevisionTHR \n#         SuccessR\n#         Death\n\nNote that our transition matrix is now time-dependent. That is, depending on the cycle, the transition probability will change. Therefore we must make a function that alters the transition matrix based on the cycle. We will fill in the transition matrix function with the appropriate transition probabilities. To get the t’th value of vector such as mr, we can use the [t] operator.\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n}\n\nCheck. Manually check that each row sums to 1 by performing some algebra.\nWe must now calculate the amount of individuals in each state for 60 cycles. We will re-use the function created in exercise 2.5 but modify it slightly for the new Markov model so that it includes the extra states and the time-dependent transition probabilities.\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs #round because we are using full population units\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\nJust like in 2.5, we will create our initial vector. Again, everyone in the population starts in the PrimaryTHR state.\n\niVec &lt;- c(1000,0,0,0,0)\n\nThen we will calculate all states for all 60 cycles\n\npopulationStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR,omrRTHR,rr= revisionRisk, mr = deathRisk,rrr=rrr,t=60)\n\nCheck. We will use rowSums to make sure that all rows total to 1000\n\nrowSums(populationStates)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-4-adapt-the-model-for-a-new-prosthesis",
    "href": "Exercises/Ch3-Exercise-35.html#step-4-adapt-the-model-for-a-new-prosthesis",
    "title": "Exercise 3.5",
    "section": "Step 4: Adapt the Model for a New Prosthesis",
    "text": "Step 4: Adapt the Model for a New Prosthesis\nTo adapt the model for a new prosthesis, we will re-use the previous results while adding the treatment effect.\nThe new revision risk adjusts the lambda value by a scalar – the hazard ratio of NP1\n\n#use the $ operator to extract the appropriate hazard ratio\nrrNP1 &lt;- survModelSummary$hazard_ratio[5]\n\nrevisionRiskNP1 &lt;- tProbsHazard(t=60,lambda = lambda*rrNP1,gamma = gamma)\n\nWe will calculate the updated states using the calculateYearlyProbs function we created earlier and filling in the appropriate arguments\n\npopulationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=revisionRiskNP1,mr=deathRisk,rrr,t=60)\n\nCheck. We will check that the row sums are equal to 1000\n\nrowSums(populationStatesNP1)\n\n [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[16] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[31] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n[46] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-5-caculate-the-costs",
    "href": "Exercises/Ch3-Exercise-35.html#step-5-caculate-the-costs",
    "title": "Exercise 3.5",
    "section": "Step 5: Caculate the Costs",
    "text": "Step 5: Caculate the Costs\nWe need to calculate the costs for both the standard and new prosthesis models. To do this, we will use the discount formula from exercise 2.5\n\n#this formula comes directly from the previous exercise\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\nWe will go through the steps for the standard treatment first\nWe will calculate Life-Years using rowSums, being sure to exclude the last state of death by using the [,-i] operator\n\nlifeYearsStandard &lt;-rowSums(populationStates[,-5])\n\nNext, we create the cost vector. The length of the vector should only then be 4, the total of the states with costs in the model.(Death can have costs that you might want to integrate in other models. But in this model, there are no costs associated with death.)\n\ncosts&lt;- c(0,0,cRevision,0)\n\nWe need to add a parameter for the initial cost. Note that we started with 1000 patients.\n\niCostStandard &lt;- cStandard*1000\n\nWe will calculate the total cost by using matrix multiplication to multiple our cost vector costs by our states matrix populationStates. We will use discountFormula to account for discounting over time.\n\ntotalCosts &lt;- populationStates[,-5] %*% costs\n\n#update the costs to account for discounting over time\ndiscCostStandard &lt;- discountFormula(totalCosts,cDR,t = 60)\n\nNext we need to repeat the previous steps for utility of the treatment over time. Just like for costs, we start by creating a utility vector for all states except death which has a utility = 0\n\nutility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n\nWe will calculate the total utility over time using matrix multiplication and then we will calculate the discounted utility.\n\ntotalQuality &lt;-  populationStates[,-5] %*% utility\nQALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t = 60)\n\nLastly, we will calculate the total cost and utilities for all cycles/person, ensure to include the initial cost of the treatment\n\nSTDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\nSTDLYs &lt;- sum(lifeYearsStandard)/1000\nSTDQALYS &lt;- sum(QALYStandard)/1000\n\nRepeat for the new prosthesis (NP1)\nAll steps should be the same for the new prosthesis, with updated costs and utilities\n\n#use rowsums to get the total life years\nlifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n\n#total and discounted costs\ntotalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costs\ndiscCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t = 60)\n\n#add the initial cost for NP1 via cNP1\niCostNP1 &lt;- cNP1*1000\n\n#Utility\ntotalQualityNP1 &lt;-  populationStatesNP1[,-5] %*% utility\nQALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t = 60)\n\n#calculate the total cost for all cycles/person, ensure to add the initial cost of the new implant\nNP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\nNP1LYs &lt;- sum(lifeYearsNP1)/1000\nNP1QALYS &lt;- sum(QALYNP1)/1000",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch3-Exercise-35.html#step-6-calculate-the-icer",
    "href": "Exercises/Ch3-Exercise-35.html#step-6-calculate-the-icer",
    "title": "Exercise 3.5",
    "section": "Step 6: Calculate the ICER",
    "text": "Step 6: Calculate the ICER\nThe final step is to calculate the ICER for the new prosthesis compared to standard care\n\n#calculate the difference in costs\ndiffCost &lt;- NP1cost-STDcost\n\n#difference in QALYs\ndiffQALY &lt;- NP1QALYS-STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 2198.487",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 3.5"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html",
    "href": "Exercises/Ch4-Exercise-47.html",
    "title": "Exercise 4.7",
    "section": "",
    "text": "Part 1: Drawing the log-normal distribution\nThis R markdown file reproduces exercise 4.7 in R from chapter 4 in the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nThe general idea of this exercise is to revisit exercise 2.5, but add uncertainty in our parameter values by assigning a probability distribution to each parameter. The various probability distributions are described in Chapter 4 and summarized in table 4.9.\nMuch of this exercise will re-use the results and functions from exercise 2.5.\nSome useful functions in R: log(x) by default calculates the natural logarithm of x. R has many built in functions to generate random numbers. For example, rnorm(n,mean,sd) generates n random numbers with mean and sd parameters.\nBecause random draws are taken from many distributions, the results of this exercise will vary for each user. To ensure reproducibility we set a seed which allows the random numbers generated to be the same for all those who use the same seed (provided the operating systems are the same).\nWe will start by setting the seed and adding in the provided parameters.\n#set a seed for reproducibility\nset.seed(123)\n\n##fixed parameters\nRR &lt;- 0.509\n\n#discount rate\ncDR &lt;- 0.06\n\n#the confidence interval\nCI_RR &lt;- c(0.365, 0.710)\n\n#drug costs, these are known and fixed\ncAZT &lt;- 2278 #cost of Zidovudine\ncLam &lt;- 2086.5 #cost of Lamivudine\nWe need to re-arrange the confidence interval formula to calculate the standard error.\nRemember that the normal distribution’s parameters are on the log scale. So, the confidence interval parameters and relative risk must be transformed accordingly.\nSE_RR &lt;- (log(CI_RR[2])-log(CI_RR[1]))/(2*1.96)\nexp(log(RR)-1.96*SE_RR)\n\n[1] 0.3649514\n\nexp(log(RR)+1.96*SE_RR)\n\n[1] 0.7099055\nNext, calculate the log mean and logRR; these are the parameters of the log-normal distribution.\nlnMeanRR &lt;- log(RR)\nlnSERR &lt;- SE_RR\nWe will now draw from the normal distribution.\nlnRRDraw &lt;- rnorm(1,mean = lnMeanRR,sd = lnSERR)\nRRSim &lt;- exp(lnRRDraw)",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-2-using-the-distribution-to-draw-random-costs",
    "href": "Exercises/Ch4-Exercise-47.html#part-2-using-the-distribution-to-draw-random-costs",
    "title": "Exercise 4.7",
    "section": "Part 2: Using the distribution to draw random costs",
    "text": "Part 2: Using the distribution to draw random costs\nWe may use the rgamma(m,shape,scale) function to draw random numbers from the gamma distribution. Recall the formulae from 4.4.3 for parameterizing the gamma distribution using the method of moments. Take care to ensure the parameterization of the gamma distribution matches that of 4.4.3. Use rgamma() to check the parameterization. The gamma distribution is parameterized in the textbook as \\(f(x \\mid \\alpha, \\beta) = \\frac{1}{\\Gamma(\\alpha), \\beta^\\alpha} \\, x^{\\alpha-1} \\, e^{-x/\\beta}\\), where \\(\\beta\\) is the “scale” parameter.\nBy default the parameterization should be \\(\\beta\\) = scale.\nFor this exercise we will take the mean costs directly from exercise 2.5 and assume the mean costs for the care are equal to their standard errors. :::{.callout-note} Note: In R we can nest the assignment operator &lt;- to save space :::\n\ndmca &lt;- SEdmca &lt;- 1701 #direct medical cost of A\ndmcb &lt;- SEdmcb &lt;- 1774 #direct medical cost of B\ndmcc &lt;- SEdmcc &lt;- 6948 #direct medical cost of C\nccca &lt;- SEccca &lt;- 1055 #community care cost of A\ncccb &lt;- SEcccb &lt;- 1278 #community care cost of B\ncccc &lt;- SEcccc &lt;- 2059 #community care cost of C\n\nTo simplify calculations, we will create a function that calculates the mean and sd of the gamma distribution based on the mean and standard deviation.\n\ngammaDistAlpha &lt;- function(mean,sd){\n  \n  return((mean^2)/(sd^2))\n  \n}\n\ngammaDistBeta &lt;- function(mean,sd){\n  \n  return((sd^2)/(mean))\n  \n}\n\nNow we will create random draws\n\ndmcaSim &lt;- rgamma(1, shape = gammaDistAlpha(dmca,SEdmca),scale = gammaDistBeta(dmca,SEdmca))\ndmcbSim &lt;- rgamma(1, shape = gammaDistAlpha(dmcb,SEdmcb),scale = gammaDistBeta(dmcb,SEdmcb))\ndmccSim &lt;- rgamma(1, shape = gammaDistAlpha(dmcc,SEdmcc),scale = gammaDistBeta(dmcc,SEdmcc))\n\ncccaSim &lt;- rgamma(1, shape = gammaDistAlpha(ccca,SEccca),scale = gammaDistBeta(ccca,SEccca))\ncccbSim &lt;- rgamma(1, shape = gammaDistAlpha(cccb,SEcccb),scale = gammaDistBeta(cccb,SEcccb))\nccccSim &lt;- rgamma(1, shape = gammaDistAlpha(cccc,SEcccc),scale = gammaDistBeta(cccc,SEcccc))",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-4",
    "href": "Exercises/Ch4-Exercise-47.html#part-4",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.3 Part 4",
    "text": "1.3 Part 4\nGenerating new transition probability matrices using the dirichlet distirbution\nRecall that the transition matrix in exercise 2.5 is given. The exercises in the excel file has the reader separate the matrix into dichotomous and non-dichotomous transition probabilities and generate random numbers using a beta distribution for the dichotomous events and dirichlet distribution for the non-dichotomous events. There is also no dirichlet distribution in Excel.\nInstead, in R, we can tackle this issue more easily. We quickly vectorize the random number generation to speed up calculations, and use the MCMCpack (Martin et al., 2011) to draw from the dirichlet distribution.\n\n#recall the transition matrix from the exercise 2.5\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\n\n#the equivalent alphas are given (note the deterministic value is alpha / (alpha + beta)), which is exactly the transition matrix given above. The betas are excluded here for simplicity\n\ntAlpha &lt;- matrix(\n  \n  c(1251, 350, 116  , 17 ,\n    0   , 731, 512  , 15 ,\n    0   , 0  , 1312 , 437, \n    0   , 0  , 0    , 1749 #note this alpha is not required as we know all are in the last state\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\n#lets use the apply function in R to quickly draw random numbers from the dirichlet distribution using the MCMC pack function and apply it to each row of tAlpha\nlibrary(MCMCpack)\n\nLoading required package: coda\n\n\nLoading required package: MASS\n\n\n##\n## Markov Chain Monte Carlo Package (MCMCpack)\n\n\n## Copyright (C) 2003-2025 Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park\n\n\n##\n## Support provided by the U.S. National Science Foundation\n\n\n## (Grants SES-0350646 and SES-0350613)\n##\n\n#note we only give n = 1 to the rdirichlet distribution as it generates a random vector of length length(alpha)\n\n#use \"1\" to specify to apply the function by rows\ntProbRand &lt;- t(apply(tAlpha,1,function(x){\n  \n  return(rdirichlet(1,x))\n}))\n\n#the rdirichlet function by default returns the vector of draws by columns, when we want these results by rows. To get the matrix back into our original form, we can just use the t() function to transpose matrix.\n\n#our new transition probability matrix\ntProbRand \n\n          [,1]      [,2]       [,3]        [,4]\n[1,] 0.7269368 0.2026091 0.05981664 0.010637517\n[2,] 0.0000000 0.5734102 0.41752856 0.009061196\n[3,] 0.0000000 0.0000000 0.75511187 0.244888130\n[4,] 0.0000000 0.0000000 0.00000000 1.000000000",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-5",
    "href": "Exercises/Ch4-Exercise-47.html#part-5",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.4 Part 5",
    "text": "1.4 Part 5\nRe-running the Markov model from exercise 2.5\nReturning to create the model in 2.5. Now that we have defined all our parameters in this exercise by drawing from random distributions. Let us take the opportunity to merge all of exercise into one function so that we can call it easily. This function will take in the costs, number of years, transition matrices of the two models, and the discount rate, and then output the costs and life years of the two treatments.\n\n#ensure to list all the previously built functions over here\ncalculatetProbCombination &lt;- function(tProbs,RR){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n#identical functions\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #Loop through all time-points and multiply the vector by \n  for(i in 1:(t)){\n\n    matReturn[i,] &lt;-   iVec %*% tProbs\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a 20 (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\n#build the function here for exercise 2.5 \nanalysisFunc &lt;- function(dmca,dmcb,dmcc,ccca,cccb,cccc,RR,cAZT,cALam,cDR,tProbs,iVec,t){\n  \n  #monotherapycost\n  \n  #call the function\n  yearlyProbs &lt;- calculateYearlyProbs(tProbs,t,iVec)\n\n  #throw error if row sums are not equal to 1\n  #stopifnot(!rowsum(yearlyProbs)==1)\n  lifeYears &lt;- rowSums(yearlyProbs[,-4])\n  \n  costA &lt;- dmca+ccca+cAZT\n  costB &lt;- dmcb+cccb+cAZT\n  costC &lt;- dmcc+cccc+cAZT\n\n  costVector &lt;- c(costA,costB,costC)\n\n  #calculate the non-discounted cost\n  nonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\n  discCost &lt;- discountFormula(nonDiscCost, discRate = cDR,t)\n  #calculate the total costs and life years over the 20 years\n  totalDiscCostMonoTherapy &lt;- sum(discCost)\n  totalLifeYearsMonoTherapy &lt;- sum(lifeYears)\n  \n  #calculate the combination therapy\n  \n  tProbsComb &lt;- calculatetProbCombination(tProbs,RR = RR)\n  \n  #check to ensure all rows sum to 1\n  rowSums(tProbsComb)\n  \n  #calculate the yearly proportions (for the first two years)\n  probsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n  \n  #calculate rest of years\n  probsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = t-2,iVec =probsCombYearly1_2[2,])\n  \n  #combine them\n  probsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n  \n    \n  #calculate the life-years\n  lifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n  \n  #calculate the costs\n  costAComb &lt;- costA+cLam\n  costBComb &lt;- costB+cLam\n  costCComb &lt;- costC+cLam\n  #combine the costs into a vector\n  costVectorComb &lt;- c(costAComb,costBComb,costCComb)\n  \n  #hint: use matrix multiplication\n  costCombNonDisc1_2 &lt;-   probsCombYearly[1:2,-4] %*% costVectorComb\n  costCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n  \n  #hint use rbind to combine the non-discounted cost\n  costCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n  \n  #calculate the discounted rate\n  costCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,t)\n  \n  #calculate the total costs and life years for the combination therapy\n  totalLifeYearsComb &lt;- sum(lifeYearsComb)\n  totalDiscCostComb &lt;- sum(costCombDisc)\n  \n  #return a list of all the relevant values\n  \n  return(list(MonoLYs = totalLifeYearsMonoTherapy,MonoDiscCost = totalDiscCostMonoTherapy,CombLYs = totalLifeYearsComb , CombDiscCost = totalDiscCostComb))\n  \n}",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-6",
    "href": "Exercises/Ch4-Exercise-47.html#part-6",
    "title": "\n1  Exercise 4.7\n",
    "section": "\n1.5 Part 6",
    "text": "1.5 Part 6\nCalculate the ICER using the function we created and the new random draws\n\n#specify the initial vector\niVec &lt;- c(1,0,0,0)\n\n#call\nresults &lt;- analysisFunc(dmca = dmcaSim,dmcb = dmcbSim,dmcc = dmccSim,ccca = cccaSim,cccb = cccaSim,cccc = ccccSim,RR = RRSim,cAZT = cAZT, cALam = cALam, cDR = cDR, tProbs = tProbRand,iVec = iVec,t = 20)\n\n\n#we can extract any element from the list by its name using the $ operator\nICER &lt;- (results$CombDiscCost-results$MonoDiscCost)/(results$CombLYs-results$MonoLYs)\nICER\n\n[1] 2720.033",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Exercise 4.7</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-3-generating-new-transition-probability-matrices-using-the-dirichlet-distirbution",
    "href": "Exercises/Ch4-Exercise-47.html#part-3-generating-new-transition-probability-matrices-using-the-dirichlet-distirbution",
    "title": "Exercise 4.7",
    "section": "Part 3: Generating new transition probability matrices using the dirichlet distirbution",
    "text": "Part 3: Generating new transition probability matrices using the dirichlet distirbution\nRecall the transition matrix given in exercise 2.5. The exercise in the excel file has the reader separate the matrix into dichotomous and non-dichotomous transition probabilities and generate random numbers using a beta distribution for the dichotomous events and dirichlet distribution for the non-dichotomous events. There is also no dirichlet distribution in Excel.\nIn R we can tackle this issue more easily. We are able to quickly vectorize the random number generation to speed up calculations, and use the MCMCpack library (Martin et al., 2011) to draw from the dirichlet distribution.\nBelow we load in the transition matrix provided in exercise 2.5\n\n#recall the transition matrix from the exercise 2.5\ntProbs &lt;- matrix(\n  c(0.721453287, 0.201845444, 0.066897347, 0.009803922,\n    0          , 0.581081081, 0.406995231, 0.011923688,\n    0          , 0          , 0.750142939, 0.249857061,\n    0          , 0          , 0          , 1\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\nThe equivalent alphas are given (note the deterministic value is alpha / (alpha + beta)), which is exactly the transition matrix given above. The betas are excluded here for simplicity\n\ntAlpha &lt;- matrix(\n  \n  c(1251, 350, 116  , 17 ,\n    0   , 731, 512  , 15 ,\n    0   , 0  , 1312 , 437, \n    0   , 0  , 0    , 1749 #note this alpha is not required as we know all are in the last state\n  ),ncol = 4, nrow = 4, byrow = T\n)\n\nLets use the apply function to quickly draw random numbers from the dirichlet distribution using the function from MCMCpack and apply it to each row of tAlpha. First, we will need load the MCMCpack library. In order to do this, you will need to have it installed. You can install it using this code install.packages(\"MCMCpack\")\n\n#load library\nlibrary(MCMCpack)\n\nLoading required package: coda\n\n\nLoading required package: MASS\n\n\n##\n## Markov Chain Monte Carlo Package (MCMCpack)\n\n\n## Copyright (C) 2003-2025 Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park\n\n\n##\n## Support provided by the U.S. National Science Foundation\n\n\n## (Grants SES-0350646 and SES-0350613)\n##\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote we only give n = 1 to the rdirichlet distribution as it generates a random vector of length(alpha).\n\n\nThe rdirichlet function by default returns the vector of draws by columns, but when we want these results by rows. To get the matrix back into our original form, we can just use the t() function to transpose matrix.\n\n#use \"1\" to specify to apply the function by rows\ntProbRand &lt;- t(apply(tAlpha,1,function(x){\n  \n  return(MCMCpack::rdirichlet(1,x))\n}))\n\n#our new transition probability matrix\ntProbRand \n\n          [,1]      [,2]       [,3]        [,4]\n[1,] 0.7269368 0.2026091 0.05981664 0.010637517\n[2,] 0.0000000 0.5734102 0.41752856 0.009061196\n[3,] 0.0000000 0.0000000 0.75511187 0.244888130\n[4,] 0.0000000 0.0000000 0.00000000 1.000000000\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nWe could also write: return(rdirichlet(1,x)) without the MCMCpack:: prefix. We’ve added the prefix so we can clearly see where a function comes from. Anything without a prefix is a function from base R, or a function we’ve written ourselves. This is really helpful when you revisit your code, particularly if you are calling functions from many different packages.",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-4-re-running-the-markov-model-from-exercise-2.5",
    "href": "Exercises/Ch4-Exercise-47.html#part-4-re-running-the-markov-model-from-exercise-2.5",
    "title": "Exercise 4.7",
    "section": "Part 4: Re-running the Markov model from exercise 2.5",
    "text": "Part 4: Re-running the Markov model from exercise 2.5\nNow that we have defined all our parameters in this exercise by drawing from random distributions where appropriate. Let us take the opportunity to merge all of the exercise into one function so that we can call it easily. This function will take in the costs, number of years, transition matrices of the two models, and the discount rate, and then output the costs and life years for each of the two treatments.\nTo begin, we will load in all of our previously built functions.\n\n#ensure to list all the previously built functions over here\ncalculatetProbCombination &lt;- function(tProbs,RR){\n  \n  newMat &lt;- tProbs\n  \n  #change the upper diagonals and multiply by risk rate\n  newMat[upper.tri(newMat)] &lt;-   newMat[upper.tri(newMat)]*RR \n  \n  diag(newMat) &lt;- 0\n  \n  #change the diagonals to be 1- the rowsums\n  diag(newMat) &lt;- 1-rowSums(newMat)\n  \n  return(newMat)\n  \n}\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n#identical functions\ncalculateYearlyProbs &lt;- function(tProbs, t, iVec){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 4)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"A\",\"B\",\"C\",\"D\")\n\n  #Loop through all time-points and multiply the vector by \n  for(i in 1:(t)){\n\n    matReturn[i,] &lt;-   iVec %*% tProbs\n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a t (years) x 4 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\nThen we will use these functions to create a single analysis function. We can build in an error check to make sure our rows sum to 1 as before.\n\nanalysisFunc &lt;- function(dmca,dmcb,dmcc,ccca,cccb,cccc,RR,cAZT,cALam,cDR,tProbs,iVec,t){\n  \n  #monotherapycost\n  \n  #call the function\n  yearlyProbs &lt;- calculateYearlyProbs(tProbs,t,iVec)\n\n  #throw error if row sums are not equal to 1\n  #stopifnot(!rowsum(yearlyProbs)==1)\n  \n  lifeYears &lt;- rowSums(yearlyProbs[,-4])\n  \n  costA &lt;- dmca+ccca+cAZT\n  costB &lt;- dmcb+cccb+cAZT\n  costC &lt;- dmcc+cccc+cAZT\n\n  costVector &lt;- c(costA,costB,costC)\n\n  #calculate the non-discounted cost\n  nonDiscCost &lt;- yearlyProbs[,-4] %*% costVector\n\n  discCost &lt;- discountFormula(nonDiscCost, discRate = cDR,t)\n  #calculate the total costs and life years over the 20 years\n  totalDiscCostMonoTherapy &lt;- sum(discCost)\n  totalLifeYearsMonoTherapy &lt;- sum(lifeYears)\n  \n  #calculate the combination therapy\n  \n  tProbsComb &lt;- calculatetProbCombination(tProbs,RR = RR)\n  \n  #check to ensure all rows sum to 1\n  rowSums(tProbsComb)\n  \n  #calculate the yearly proportions (for the first two years)\n  probsCombYearly1_2 &lt;- calculateYearlyProbs(tProbsComb,t = 2,iVec = iVec)\n  \n  #calculate rest of years\n  probsCombYearly3_20 &lt;- calculateYearlyProbs(tProbs,t = t-2,iVec =probsCombYearly1_2[2,])\n  \n  #combine them\n  probsCombYearly &lt;- rbind(probsCombYearly1_2,probsCombYearly3_20)\n  \n  #calculate the life-years\n  lifeYearsComb &lt;- rowSums(probsCombYearly[,-4])\n  \n  #calculate the costs\n  costAComb &lt;- costA+cLam\n  costBComb &lt;- costB+cLam\n  costCComb &lt;- costC+cLam\n  \n  #combine the costs into a vector\n  costVectorComb &lt;- c(costAComb,costBComb,costCComb)\n  \n  #use matrix multiplication to calculate yearly costs\n  costCombNonDisc1_2 &lt;-   probsCombYearly[1:2,-4] %*% costVectorComb\n  costCombNonDisc3_20 &lt;- probsCombYearly[3:20,-4] %*% costVector\n  \n  #use rbind to combine the non-discounted cost\n  costCombNonDisc &lt;- rbind(costCombNonDisc1_2,costCombNonDisc3_20)\n  \n  #calculate the discounted costs\n  costCombDisc &lt;- discountFormula(costCombNonDisc, discRate = cDR,t)\n  \n  #calculate the total costs and life years for the combination therapy\n  totalLifeYearsComb &lt;- sum(lifeYearsComb)\n  totalDiscCostComb &lt;- sum(costCombDisc)\n  \n  #return a list of all the relevant values\n  return(list(MonoLYs = totalLifeYearsMonoTherapy,MonoDiscCost = totalDiscCostMonoTherapy,CombLYs = totalLifeYearsComb , CombDiscCost = totalDiscCostComb))\n  \n}",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-5-calculating-the-icer",
    "href": "Exercises/Ch4-Exercise-47.html#part-5-calculating-the-icer",
    "title": "Exercise 4.7",
    "section": "Part 5: Calculating the ICER",
    "text": "Part 5: Calculating the ICER\nJust as in exercise 2.5, our last step is to calculate the ICER. We will use the function we created and the new random draws.\n\n#specify the initial vector\niVec &lt;- c(1,0,0,0)\n\n#call our new analysis function\nresults &lt;- analysisFunc(dmca = dmcaSim,dmcb = dmcbSim,dmcc = dmccSim,ccca = cccaSim,cccb = cccaSim,cccc = ccccSim,RR = RRSim,cAZT = cAZT, cALam = cALam, cDR = cDR, tProbs = tProbRand,iVec = iVec,t = 20)\n\nWe can extract any element from the list by its name using the $ operator\n\nICER &lt;- (results$CombDiscCost-results$MonoDiscCost)/(results$CombLYs-results$MonoLYs)\nICER\n\n[1] 2720.033",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html",
    "href": "Exercises/Ch4-Exercise-48.html",
    "title": "Exercise 4.8",
    "section": "",
    "text": "Part 1\nThis R markdown file reproduces exercise 4.8 in R from Chapter 4 in the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nThis exercise re-evaluates the hip-replacement analysis from exercise 3.5. However, we assign probability distributions to parameters that are, in general, estimated with uncertainty.\nAssigning beta distributions to probability parameters\nConsider this verbatim quote from 4.8.2 Section 2:\n“The hospital records of a sample of 100 patients receiving a primary THR were examined retrospectively. Of these patients, two patients died either during or immediately following the procedure. The operative mortality for the procedure is therefore estimated to be 2 per cent.”\nand\n“The hospital records of a sample of 100 patients having experienced a revision procedure to replace a failed primary THR were reviewed at one year. During this time, four patients had undergone a further revision procedure.”\n#set a seed for reproducibility\nset.seed(12345)\n\n#some deterministic parameters from the previous exercise, no changes are needed\n\nage &lt;- 60\nmale &lt;- 0\n\ncDR &lt;- 0.06\noDR &lt;- 0.015\n\n\nomrPTHR &lt;- rbeta(1,2,98)   #operative mortality rate following primary THR\n\n#use the same distribution for the revision risk as no information is provided\nomrRTHR &lt;- rbeta(1,2,98)  #operative mortality rate following revision THR\n  \n\nrrr &lt;- rbeta(1,4,96) #re-revision risk\n\n\n#let us compare the standard errors of each estimate by using the 1. the sampling distribution based on the central limit theorem, and the method of moments of the beta distribution.\n\nSE_p &lt;- function(p,n){\n  return(sqrt(p*(1-p)/n))\n  \n}\n\nSE_beta &lt;- function(alpha,beta){\n\n  return(sqrt(alpha*beta/((alpha+beta)^2 *(alpha+beta+1))))\n}\n\nSE_omrPTHR_p &lt;- SE_p(0.02,100) \nSE_omrPTHR_beta &lt;- SE_beta(2,98)\n\n\nSE_rrr_p &lt;- SE_p(0.04,100) \nSE_rrr_beta &lt;- SE_beta(4,96)\nLets compare the two standard error\nSE_rrr_p\n\n[1] 0.01959592\n\nSE_rrr_beta\n\n[1] 0.01949867\nNotice that the two standard errors are almost identical with the absolute difference being about 0.0001, this shows that using method of moments with the beta distribution can approximate the standard error of the the sample proportion",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-2",
    "href": "Exercises/Ch4-Exercise-48.html#part-2",
    "title": "Exercise 4.8",
    "section": "Part 2",
    "text": "Part 2\nUsing the gamma distribution for costs\nConsider the following verbatim quote from Section 4.8.2 Part 3\n“A number of units involved in THR were reviewed and the mean cost of a revision procedure was found to be £5294 with a standard error of £1487.”\nThe gamma distribution is parameterized in the textbook as \\(f(x \\mid \\alpha, \\beta) = \\frac{1}{\\Gamma(\\alpha), \\beta^\\alpha} \\, x^{\\alpha-1} \\, e^{-x/\\beta}\\), where \\(\\beta\\) is the “scale” parameter. To match this parameterization we must use the “scale” parameter rather than the “rate” parameter when inputting \\(\\beta\\).\n\n#fill in the mean and SE for the gamma distribution using the method of moments\n\nalpha &lt;- (5294/1487)^2\nbeta &lt;- 1487^2 / 5294\n\n#ensure that we select scale for the beta value as there is a rate parameter (1/scale)\ncRevision &lt;- rgamma(1,shape = alpha,scale = beta)\n\n#other fixed costs\ncStandard &lt;- 394 #cost of standard implant\ncNP1 &lt;- 579 #cost of new implant",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-3",
    "href": "Exercises/Ch4-Exercise-48.html#part-3",
    "title": "Exercise 4.8",
    "section": "Part 3",
    "text": "Part 3\nUsing the beta distribution to generate utility parameters.\nConsider using the method of moments to draw from the beta distribution based on the this verbatim quote from Section 4.8.2 Section 3) “A study was instigated to explore the utility weights subjects placed on different outcomes of THR related to the states of the Markov model – the following results were calculated in terms of mean (standard error) by state: Successful primary – 0.85 (0.03) Successful revision – 0.75 (0.04) Revision – 0.3 (0.03)”\n\n#because we need to calculate alpha and beta for the beta distribution simultaneously as the beta depends on alpha, we can merge all operations into one function.\n#create a function that calculates alpha and beta from the mean and standard errors and subsequently drawing from the beta distribution.\n\n\ndrawBetaMethodMoments &lt;- function(n,mu,s){\n  \n  #functions estimates alpha and beta using the method of moments then draws from the beta distribution\n  alpha &lt;- ((mu*(1-mu)/s^2) -1)*mu\n  beta &lt;- alpha*(1-mu )/mu\n  \n  #draw our random number\n  draw &lt;- rbeta(n,alpha,beta)\n  \n  return(draw)\n}\n\n#draw our beta distribution based on the mean and standard errors\n\nuSuccessP &lt;- drawBetaMethodMoments(1,0.85,0.03)\nuSuccessR &lt;- drawBetaMethodMoments(1,0.75,0.04)\nuRevision &lt;- drawBetaMethodMoments(1,0.3,0.03)",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-4",
    "href": "Exercises/Ch4-Exercise-48.html#part-4",
    "title": "Exercise 4.8",
    "section": "Part 4",
    "text": "Part 4\nDrawing from a multivariate normal distribution\nOne of the many advantages R has over Excel is that it has access to more specialized function. The excel exercise has the reader generate multivariate normal random numbers via the uni-variate normal distribution. Although there is some nice theory regarding the univariate and multivariate normal distributions, in R we can simply draw directly from a multivariate normal distribution via well established packages such as MASS to simulate the hazard model from exercise 3.5\nFor example the mvrnorm() distribution only requires the covariance matrix, and a cholesky decomposition is not required (although it would likely more computationally efficient). On modern hardware, there is little difference unless we are generating multivariate normals with very high dimentionality.\n\n#If you don't have MASS installed, you will need to install the package using install.packages() function\n#install.packages(\"MASS\")\n\n#load the package\nlibrary(MASS)\n\n#the survival model from exercise 3.5\nsurvModelSummary &lt;- data.frame(\n  \n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n#covariance matrix provided\ncovMat &lt;- matrix(\n  c(0.0022515  , -0.005691 , 0.000000028, 0.0000051, 0.000259,\n   -0.005691   ,  0.0432191,-0.000783   ,-0.007247 ,-0.000642,\n    0.000000028, -0.000783 , 2.716e-05  , 0.000033 ,-0.000111,\n    0.0000051  , -0.007247 , 0.000033   , 0.0118954, 0.000184,\n    0.000259   , -0.000642 ,-0.000111   , 0.000184 , 0.1463686),\n  nrow = 5, ncol = 5, byrow = T\n)\n\n#name the matrix columns and rows\ncolnames(covMat) &lt;- rownames(covMat) &lt;- c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\")\n\n\n\n\n#note we can easily calculate the cholesky decomposition in R if needed\ncholeskyMat &lt;- chol(covMat)\n\n\n\nnormDraw &lt;- mvrnorm(1, mu = survModelSummary$coefficient,Sigma = covMat)\n#as a sanity check, compare the coefficient values from normDraw with those from survModelFit. The coefficients should be of similar magnitude and direction but the exact values may differ\nnormDraw\n\n    lngamma        cons         age        male         NP1 \n 0.44750793 -5.87094270 -0.02999998  0.81459101 -1.39162671 \n\n#remember these are on the log scale, we can extract the necessary parameters\n\n#we can extract the necessary parameters using the [i] operator, or, since the vector has named elements, we can be more explicit by using ['name'] instead\ngamma &lt;- exp(normDraw['lngamma'])\nlambda &lt;- exp(normDraw['cons'] + normDraw['age']*age + normDraw['male']*male)\nrrNP1 &lt;- exp(normDraw['NP1'])",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-5",
    "href": "Exercises/Ch4-Exercise-48.html#part-5",
    "title": "Exercise 4.8",
    "section": "Part 5",
    "text": "Part 5\nWe combine all the functions built in the previous exercises to create an analysis function that completes the NP1 ICER calculations in one call.\nWe bring all previous functions from exercise 3.5. As in Exercise 4.7, we create an analysis function that takes in all necessary parameters and outputs the appropriate cost and QALYs to calculate the ICER.\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n  \n}\n\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n}\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs \n    \n    #update iVec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a 60 (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n\nanalysisNP1 &lt;- function(omrPTHR,omrRTHR,mr,rrr,cPrimary,cRevision,cPSuccess,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){\n\n  #calculate the revision risk\n    rr &lt;- tProbsHazard(t=t,lambda = lambda,gamma = gamma)\n    mr &lt;- sapply(1:t,function(x){\n    \n    #calculate which index select based on the age group\n    inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n    \n    #select the gender columns\n    #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n    genderCol &lt;- ifelse(male ==1,3,4)\n    \n    return(yearlyTProbs[inds,genderCol])\n    \n  })\n    \n  #calculate standard states\n  standPopStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)\n  lifeYearsStandard &lt;- rowSums(standPopStates[,-5])\n  #excludes death year\n  costVec &lt;- c(0,0,cRevision,0)\n\n  #add a parameter for the initial cost we had 1000 initial patients\n  iCostStandard &lt;- cStandard*1000\n  \n  #first calculate the total cost\n  totalCosts &lt;- standPopStates[,-5] %*% costVec\n  \n  #calculate the discounted cost\n  discCostStandard &lt;- discountFormula(totalCosts,cDR,t=t)\n  \n  #calculate the quality adjusted life years by creating a vector for each state utility except death\n  utility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n  \n  #multiply by the cohort\n  totalQuality &lt;-  standPopStates[,-5] %*% utility\n  QALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  STDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\n  STDLYs &lt;- sum(lifeYearsStandard)/1000\n  STDQALYS &lt;- sum(QALYStandard)/1000\n\n  \n  ###repeat this for the NP1###\n  rrNP1_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np1\n  lifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n  \n  #total and discounted costs\n  totalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costVec\n  discCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t=t)\n  #add the initial cost for NP1\n  iCostNP1 &lt;- cNP1*1000\n  #Utility\n  totalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\n  QALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\n  NP1LYs &lt;- sum(lifeYearsNP1)/1000\n  NP1QALYS &lt;- sum(QALYNP1)/1000\n  \n  #returns a list of discounted cost and QALYs for each method\n  return(list(STDcost = STDcost, STDQALYS = STDQALYS, NP1cost = NP1cost,NP1QALYS = NP1QALYS, ICER = (NP1cost-STDcost)/(NP1QALYS-STDQALYS)))\n  \n}",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-6",
    "href": "Exercises/Ch4-Exercise-48.html#part-6",
    "title": "Exercise 4.8",
    "section": "Part 6",
    "text": "Part 6\nCalculating the ICER\n\n#call the created function\niVec &lt;- c(1000,0,0,0,0)\nt &lt;- 60\n\nresults &lt;- analysisNP1(omrPTHR,omrRTHR,mr,rrr,cPrimary,cRevision,cPSuccess,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t)\n\n\n#calculate the difference in costs\ndiffCost &lt;- results$NP1cost-results$STDcost\n\n#difference in QALYs\ndiffQALY &lt;- results$NP1QALYS-results$STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 1074.879",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.8"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-1",
    "href": "Exercises/Ch4-Exercise-48.html#part-1",
    "title": "\n2  Exercise 4.8\n",
    "section": "",
    "text": "“The hospital records of a sample of 100 patients receiving a primary THR were examined retrospectively. Of these patients, two patients died either during or immediately following the procedure. The operative mortality for the procedure is therefore estimated to be 2 per cent.”\n\n\n\n“The hospital records of a sample of 100 patients having experienced a revision procedure to replace a failed primary THR were reviewed at one year. During this time, four patients had undergone a further revision procedure.”",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 4.8</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-47.html#part-1-drawing-the-log-normal-distribution",
    "href": "Exercises/Ch4-Exercise-47.html#part-1-drawing-the-log-normal-distribution",
    "title": "Exercise 4.7",
    "section": "",
    "text": "Check\n\n\n\nWe can check we’ve done it properly by using the formulas below, They should provide the same results as the confidence intervals we entered above as CI_RR.",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 4.7"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-1-assigning-beta-distributions-to-probability-parameters",
    "href": "Exercises/Ch4-Exercise-48.html#part-1-assigning-beta-distributions-to-probability-parameters",
    "title": "\n2  Exercise 4.8\n",
    "section": "",
    "text": "“The hospital records of a sample of 100 patients receiving a primary THR were examined retrospectively. Of these patients, two patients died either during or immediately following the procedure. The operative mortality for the procedure is therefore estimated to be 2 per cent.”\n\n\n\n“The hospital records of a sample of 100 patients having experienced a revision procedure to replace a failed primary THR were reviewed at one year. During this time, four patients had undergone a further revision procedure.”",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 4.8</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-2-using-the-gamma-distribution-for-costs",
    "href": "Exercises/Ch4-Exercise-48.html#part-2-using-the-gamma-distribution-for-costs",
    "title": "\n2  Exercise 4.8\n",
    "section": "\n2.2 Part 2: Using the gamma distribution for costs",
    "text": "2.2 Part 2: Using the gamma distribution for costs\nConsider the following verbatim quote from Section 4.8.2 Part 3:\n\n“A number of units involved in THR were reviewed and the mean cost of a revision procedure was found to be £5294 with a standard error of £1487.”\n\nThe gamma distribution is parameterized in the textbook as: \\[f(x \\mid \\alpha, \\beta) = \\frac{1}{\\Gamma(\\alpha), \\beta^\\alpha} \\, x^{\\alpha-1} \\, e^{-x/\\beta}\\] where \\(\\beta\\) is the “scale” parameter. To match this parameterization we must use the scale parameter rather than the rate parameter when inputting \\(\\beta\\).\nWe will fill in the mean and SE for the gamma distribution using the method of moments, and ensure we select scale for the beta value as there is a rate parameter (1/scale)\n\nalpha &lt;- (5294/1487)^2\nbeta &lt;- 1487^2 / 5294\n\n#select scale for the beta value as there is a rate parameter\ncRevision &lt;- rgamma(1,shape = alpha,scale = beta)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 4.8</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-3-using-the-beta-distribution-to-generate-utility-parameters",
    "href": "Exercises/Ch4-Exercise-48.html#part-3-using-the-beta-distribution-to-generate-utility-parameters",
    "title": "\n2  Exercise 4.8\n",
    "section": "\n2.3 Part 3: Using the beta distribution to generate utility parameters",
    "text": "2.3 Part 3: Using the beta distribution to generate utility parameters\nConsider using the method of moments to draw from the beta distribution based on the this quote from Section 4.8.2 Section 3:\n\n“A study was instigated to explore the utility weights subjects placed on different outcomes of THR related to the states of the Markov model – the following results were calculated in terms of mean (standard error) by state:\n\nSuccessful primary – 0.85 (0.03)\nSuccessful revision – 0.75 (0.04)\nRevision – 0.3 (0.03)”\n\n\nBecause we need to calculate alpha and beta for the beta distribution simultaneously as the beta depends on alpha, we can merge all operations into one function.\nWe will create a function that calculates alpha and beta from the mean and standard errors and subsequently draws from the beta distribution.\n\ndrawBetaMethodMoments &lt;- function(n,mu,s){\n  \n  #functions estimates alpha and beta using the method of moments \n  #then draws from the beta distribution\n  alpha &lt;- ((mu*(1-mu)/s^2) -1)*mu\n  beta &lt;- alpha*(1-mu )/mu\n  \n  #draw our random number\n  draw &lt;- rbeta(n,alpha,beta)\n  \n  return(draw)\n}\n\nNow we will draw our beta distribution based on the mean and standard errors using our newly created function.\n\nuSuccessP &lt;- drawBetaMethodMoments(1,0.85,0.03)\nuSuccessR &lt;- drawBetaMethodMoments(1,0.75,0.04)\nuRevision &lt;- drawBetaMethodMoments(1,0.3,0.03)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 4.8</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-4-drawing-from-a-multivariate-normal-distribution",
    "href": "Exercises/Ch4-Exercise-48.html#part-4-drawing-from-a-multivariate-normal-distribution",
    "title": "\n2  Exercise 4.8\n",
    "section": "\n2.4 Part 4: Drawing from a multivariate normal distribution",
    "text": "2.4 Part 4: Drawing from a multivariate normal distribution\nOne of the advantages R has over Excel is that it has access to morespecialized functions. The excel exercise has the reader generate multivariate normal random numbers via the uni-variate normal distribution. Although there is some nice theory regarding the univariate and multivariate normal distributions, in R we can simply draw directly from a multivariate normal distribution via well established packages such as MASS to simulate the hazard model from exercise 3.5\nFor example the mvrnorm() distribution only requires the covariance matrix, and a cholesky decomposition is not required (although it would likely be more computationally efficient). On modern hardware, there is little difference unless we are generating multivariate normals with very high dimensionality.\n\n\n\n\n\n\nNote\n\n\n\nIf you don’t have MASS installed, you will need to install the package using this code: install.packages(\"MASS\")\n\n\nTo start, we will load the MASS package and input the survival model and covariance matrix provided in the exercise.\n\n#load the package\nlibrary(MASS)\n\n#the survival model from exercise 3.5\nsurvModelSummary &lt;- data.frame(\n  \n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n#covariance matrix provided\ncovMat &lt;- matrix(\n  c(0.0022515  , -0.005691 , 0.000000028, 0.0000051, 0.000259,\n   -0.005691   ,  0.0432191,-0.000783   ,-0.007247 ,-0.000642,\n    0.000000028, -0.000783 , 2.716e-05  , 0.000033 ,-0.000111,\n    0.0000051  , -0.007247 , 0.000033   , 0.0118954, 0.000184,\n    0.000259   , -0.000642 ,-0.000111   , 0.000184 , 0.1463686),\n  nrow = 5, ncol = 5, byrow = T\n)\n\n#name the matrix columns and rows\ncolnames(covMat) &lt;- rownames(covMat) &lt;- c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\")\n\nAlthough we don’t need to, it’s worth noting that we can easily calculate the cholesky decomposition in R\n\ncholeskyMat &lt;- chol(covMat)\n\n\n\n\n\n\n\nCheck\n\n\n\nCompare the coefficient values from normDraw with those from survModelFit. The coefficients should be of similar magnitude and direction but the exact values may differ.\n\n\n\nnormDraw &lt;- MASS::mvrnorm(1, mu = survModelSummary$coefficient,Sigma = covMat)\n\nnormDraw\n\n    lngamma        cons         age        male         NP1 \n 0.44750793 -5.87094270 -0.02999998  0.81459101 -1.39162671 \n\n\nRemember these values are on the log scale.\nWe can extract the necessary parameters using the [i] operator, or, since the vector has named elements, we can be more explicit by using ['name'] instead\n\ngamma &lt;- exp(normDraw['lngamma'])\nlambda &lt;- exp(normDraw['cons'] + normDraw['age']*age + normDraw['male']*male)\nrrNP1 &lt;- exp(normDraw['NP1'])",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 4.8</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-5-combining-all-our-functions",
    "href": "Exercises/Ch4-Exercise-48.html#part-5-combining-all-our-functions",
    "title": "\n2  Exercise 4.8\n",
    "section": "\n2.5 Part 5: Combining all our functions",
    "text": "2.5 Part 5: Combining all our functions\nWe combine all the functions built in the exercise 3.5 to create an analysis function that completes the NP1 ICER calculations in a single call.\nAs in Exercise 4.7, we create an analysis function that takes in all necessary parameters and outputs the appropriate cost and QALYs to calculate the ICER.\nThe first step is to load in all of our previous functions\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n  \n}\n\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #rr is revision risk, mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n}\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs \n    \n    #update iVec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a t (years) x 5 (states) matrix where the rows represent \n  #the proportion in a given state at year t\n  \n}\n\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\nThen we compile all the functions into a single analysis function:\n\nanalysisNP1 &lt;- function(omrPTHR,omrRTHR,mr,rrr,cPrimary,cRevision,cPSuccess,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){\n\n  #calculate the revision risk\n    rr &lt;- tProbsHazard(t=t,lambda = lambda,gamma = gamma)\n    mr &lt;- sapply(1:t,function(x){\n    \n    #calculate which index select based on the age group\n    inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n    \n    #select the gender columns\n    #if else takes 3 arguments, the first is a logical check, \n    #if true, it returns the second value, \n    #if false it returns the 3rd argument. \n    #Equivalent code can be written use if(x){}else{}.\n    genderCol &lt;- ifelse(male ==1,3,4)\n    \n    return(yearlyTProbs[inds,genderCol])\n    \n  })\n    \n  #calculate standard states\n  standPopStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)\n  lifeYearsStandard &lt;- rowSums(standPopStates[,-5])\n  #excludes death year\n  costVec &lt;- c(0,0,cRevision,0)\n\n  #add a parameter for the initial cost we had 1000 initial patients\n  iCostStandard &lt;- cStandard*1000\n  \n  #first calculate the total cost\n  totalCosts &lt;- standPopStates[,-5] %*% costVec\n  \n  #calculate the discounted cost\n  discCostStandard &lt;- discountFormula(totalCosts,cDR,t=t)\n  \n  #calculate the quality adjusted life years by creating \n  #a vector for each state utility except death\n  utility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n  \n  #multiply by the cohort\n  totalQuality &lt;-  standPopStates[,-5] %*% utility\n  QALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  STDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\n  STDLYs &lt;- sum(lifeYearsStandard)/1000\n  STDQALYS &lt;- sum(QALYStandard)/1000\n\n  \n  ###repeat this for the NP1###\n  rrNP1_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np1\n  lifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n  \n  #total and discounted costs\n  totalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costVec\n  discCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t=t)\n  #add the initial cost for NP1\n  iCostNP1 &lt;- cNP1*1000\n  #Utility\n  totalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\n  QALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\n  NP1LYs &lt;- sum(lifeYearsNP1)/1000\n  NP1QALYS &lt;- sum(QALYNP1)/1000\n  \n  #returns a list of discounted cost and QALYs for each method\n  return(list(STDcost = STDcost, STDQALYS = STDQALYS, NP1cost = NP1cost,NP1QALYS = NP1QALYS, ICER = (NP1cost-STDcost)/(NP1QALYS-STDQALYS)))\n  \n}",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 4.8</span>"
    ]
  },
  {
    "objectID": "Exercises/Ch4-Exercise-48.html#part-6-calculating-the-icer",
    "href": "Exercises/Ch4-Exercise-48.html#part-6-calculating-the-icer",
    "title": "\n2  Exercise 4.8\n",
    "section": "\n2.6 Part 6: Calculating the ICER",
    "text": "2.6 Part 6: Calculating the ICER\nNow we will use our analysis function to calculate the ICER.\nWe will need to provide the starting vector, and the number of cycles we want to calculate, and then we can load our arguments into the primary analysis function.\n\n#call the created function\niVec &lt;- c(1000,0,0,0,0)\nt &lt;- 60\n\nresults &lt;- analysisNP1(omrPTHR,omrRTHR,mr,rrr,cPrimary,cRevision,cPSuccess,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t)\n\nWe will use these results to calculate the differences in costs and QALYs, and then compute the ICER.\n\n#calculate the difference in costs\ndiffCost &lt;- results$NP1cost-results$STDcost\n\n#difference in QALYs\ndiffQALY &lt;- results$NP1QALYS-results$STDQALYS\n\n#calculate the ICER\nICER &lt;- diffCost/diffQALY\n\nICER \n\n[1] 1074.879",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise 4.8</span>"
    ]
  },
  {
    "objectID": "Chapters/Ch2-Decision-Modeling-for-Health-Economic-Evaluation.html",
    "href": "Chapters/Ch2-Decision-Modeling-for-Health-Economic-Evaluation.html",
    "title": "Chapter 2 - Decision Modelling for Health Economic Evaluation",
    "section": "",
    "text": "Overview of Exercises\nThis section of the guide presents the exercises from Decision Modelling for Health Economic Evaluation by Andrew Briggs, Mark Sculpher, and Karl Claxton. We have translated these tasks from their original Excel format into R, providing an opportunity to practice decision modelling using a reproducible, script-based approach.\nThe original book is a key reference for decision modelling in health economics. While the official supporting materials are provided in other formats\n(available here), our contribution is to:\nThrough these exercises, learners develop skills in writing functions, performing matrix operations, running simulations, and incorporating parameter uncertainty via probability distributions and probabilistic sensitivity analysis. The exercises also introduce widely used R packages:\nBy combining these tools, the exercises strengthen both programming fluency and applied expertise in constructing, analyzing, and interpreting health economic decision models.",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Chapter 2 - Decision Modelling for Health Economic Evaluation"
    ]
  },
  {
    "objectID": "Chapters/Ch2-Decision-Modeling-for-Health-Economic-Evaluation.html#overview-of-exercises",
    "href": "Chapters/Ch2-Decision-Modeling-for-Health-Economic-Evaluation.html#overview-of-exercises",
    "title": "Chapter 2 - Decision Modelling for Health Economic Evaluation",
    "section": "",
    "text": "dplyr and tidyr for data manipulation\nggplot2 for creating visualizations such as cost-effectiveness planes\nMASS and MCMCpack for probability distributions and simulation, alongside base R functions",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Chapter 2 - Decision Modelling for Health Economic Evaluation"
    ]
  },
  {
    "objectID": "Exercises/Ch5-Exercise-57.html",
    "href": "Exercises/Ch5-Exercise-57.html",
    "title": "Exercise 5.7",
    "section": "",
    "text": "Part 1: Setting-up the analysis\nThis R markdown file reproduces exercise 5.7 in R from Chapter 5 in the book “Decision Modelling for Health Economic Evaluation” by Andrew Briggs, Mark Sculpher, and Karl Claxton\nIn this exercise we are going to extend the probabilistic parameter generation from exercise 4.8 by using simulations to account for the combined uncertainty of the parameters. As R is a language specifically for statistical computing, it is not surprising that statistical simulations are frequently run in R. These simulations can be constructed using a variety of core R functions. In this exercise, we will use either for-loops directly or call wrappers such as lapply, apply, or sapply.\nLet’s revisit exercise 4.8 by creating a few more functions that:\nFirst we copy the analysis function from 4.8 and create another function that generates parameters.\nWe start by initializing all fixed parameters, bring over all the functions from the previous exercises. We also load the MASS package required to sample random numbers from the multivariate normal distribution.\nlibrary(MASS)\n\ncStandard &lt;- 394 #cost of standard implant\ncNP1 &lt;- 579 #cost of new implant\n\ncDR &lt;- 0.06 #cost discount rate\noDR &lt;- 0.015 #outcome discount rate\nage &lt;- 60 #average age of all patients at receipt of primary implant\nmale &lt;- 0 #sex indicator (0 for female, 1 for male)\n\niVec &lt;- c(1000,0,0,0,0) #starting vector; everyone starts in the first state\nt &lt;- 60 #number of cycles\n\ncovMat &lt;- matrix(\n  c(0.0022515  , -0.005691 , 0.000000028, 0.0000051, 0.000259,\n   -0.005691   ,  0.0432191,-0.000783   ,-0.007247 ,-0.000642,\n    0.000000028, -0.000783 , 2.716e-05  , 0.000033 ,-0.000111,\n    0.0000051  , -0.007247 , 0.000033   , 0.0118954, 0.000184,\n    0.000259   , -0.000642 ,-0.000111   , 0.000184 , 0.1463686),\n  nrow = 5, ncol = 5, byrow = T\n)\n\ncolnames(covMat) &lt;- rownames(covMat) &lt;- c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\")\n\nsurvModelSummary &lt;- data.frame(\n  \n  variable = c(\"lngamma\",\"cons\",\"age\",\"male\",\"NP1\"),\n  coefficient = c(0.3740968,-5.490935,-0.0367022,0.768536,-1.344474),\n  SE = c(0.0474501,0.207892,0.0052112,0.109066,0.3825815)\n)\nsurvModelSummary$hazard_ratio &lt;- exp(survModelSummary$coefficient)\n\n\n\n\ndrawBetaMethodMoments &lt;- function(n,mu,s){\n  \n  #functions estimates alpha and beta using the method of moments then draws from the beta distribution\n  alpha &lt;- ((mu*(1-mu)/s^2) -1)*mu\n  beta &lt;- alpha*(1-mu )/mu\n  \n  #draw our random number\n  draw &lt;- rbeta(n,alpha,beta)\n  \n  return(draw)\n}\n\n\ntProbsHazard &lt;- function(t,lambda,gamma){\n   \n  return(1-exp(lambda*(((1:t)-1)^gamma - ((1:t)^gamma))))\n   \n}\n\n\ntProbs_time &lt;- function(omrPTHR,omrRTHR,rr,mr,rrr,t){\n  #omrPTHR is operative mortality rate following primary THR\n  #omrRTHR is operative mortality rate following revision THR\n  #rrr is re-revision risk\n  #mr is mortality risk\n  \n  tProbs &lt;- matrix(\n  c(0, 1-(omrPTHR),     0,     0,                   omrPTHR,\n    0, 1-(rr[t]+mr[t]), rr[t], 0,                   mr[t],\n    0, 0,               0,     1-(omrRTHR + mr[t]), omrRTHR + mr[t],\n    0, 0,               rrr,   1-(rrr+mr[t]),       mr[t],\n    0, 0,               0,     0,                   1\n  ),ncol = 5, nrow = 5, byrow = T\n)\n  \n}\n\n#provided death rates and yearly transition probabilities\ndeathRates &lt;- data.frame(\n  Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n  Males = c(1.51,3.93,10.9,31.6,80.1,187.9),\n  Females = c(0.99,2.6,6.7,19.3,53.5,154.8)\n  \n)\nyearlyTProbs &lt;- data.frame(\n    Age = c(\"35-44\",\"45-54\",\"55-64\",\"65-74\",\"75-84\",\"85 and over\"),\n    Index = c(35,45,55,65,75,85),\n    Males = c(0.00151,0.00393,0.0109,0.0316,0.0801,0.1879),\n    Females = c(0.00099,0.0026,0.0067,0.0193,0.0535,0.1548)\n)\n\n\ndiscountFormula &lt;- function(nonDiscount,discRate,t){\n  \n  return(nonDiscount/(1+discRate)^(1:t))\n  \n}\n\n\n\ncalculateYearlyProbs &lt;- function(iVec,omrPTHR,omrRTHR,rr,mr,rrr,t){\n  \n  #create empty matrix that we will fill in\n  \n  matReturn &lt;- matrix(nrow = t, ncol = 5)\n  \n  #initialize first vector of proportions\n  \n  #create column names\n  colnames(matReturn) &lt;- c(\"PrimaryTHR\",\"SuccessP\",\"RevisionTHR\",\"SucessR\",\"Death\")\n\n  for(i in 1:t){\n    \n    #get the corresponding transition matrix based on the time\n    tProbs &lt;- tProbs_time(omrPTHR,omrRTHR,rr,mr,rrr,i)\n    \n    matReturn[i,] &lt;-   iVec %*% tProbs \n    \n    #update ivec\n    iVec &lt;- iVec %*% tProbs\n    \n  }\n  return(matReturn)\n  \n  #returns a t (years) x 5 (states) matrix where the rows represent the proportion in a given state at year t\n  \n}\n\n\n#complete primary analysis function for NP1\nanalysisNP1 &lt;- function(omrPTHR,omrRTHR,mr,rrr,rrNP1,cPrimary,cRevision,cStandard,uSuccessP,uSuccessR,uRevision,cDR,oDR,cNP1,gamma,lambda,iVec,t){\n\n  #calculate the revision risk\n    rr &lt;- tProbsHazard(t=t,lambda = lambda,gamma = gamma)\n    mr &lt;- sapply(1:t,function(x){\n    \n    #calculate which index select based on the age group\n    inds &lt;- sum(x+age &gt;= yearlyTProbs$Index)\n    \n    #select the gender columns\n    #if else takes 3 arguments, the first is a logical check, if true, it returns the second value, if false it returns the 3rd argument. Equivalent code can be written use if(x){}else{}.\n    genderCol &lt;- ifelse(male ==1,3,4)\n    \n    return(yearlyTProbs[inds,genderCol])\n    \n  })\n    \n  #calculate standard states\n  standPopStates &lt;- calculateYearlyProbs(iVec = iVec,omrPTHR=omrPTHR, omrRTHR=omrPTHR,rr= rr, mr = mr,rrr=rrr,t=t)\n  lifeYearsStandard &lt;- rowSums(standPopStates[,-5])\n  #excludes death year\n  costVec &lt;- c(0,0,cRevision,0)\n\n  #add a parameter for the initial cost we had 1000 initial patients\n  iCostStandard &lt;- cStandard*1000\n  \n  #first calculate the total cost\n  totalCosts &lt;- standPopStates[,-5] %*% costVec\n  \n  #calculate the discounted cost\n  discCostStandard &lt;- discountFormula(totalCosts,cDR,t=t)\n  \n  #calculate the quality adjusted life years by creating a vector for each state utility except death\n  utility&lt;- c(0,uSuccessP,uRevision,uSuccessR)\n  \n  #multiply by the cohort\n  totalQuality &lt;-  standPopStates[,-5] %*% utility\n  QALYStandard &lt;- discountFormula(totalQuality,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  STDcost &lt;- sum(c(iCostStandard,discCostStandard))/1000\n  STDLYs &lt;- sum(lifeYearsStandard)/1000\n  STDQALYS &lt;- sum(QALYStandard)/1000\n\n  \n  ###repeat this for the NP1###\n  rrNP1_vec &lt;- tProbsHazard(t,lambda = lambda*rrNP1,gamma = gamma)\n\n  #call the previous function created\n  populationStatesNP1 &lt;- calculateYearlyProbs(iVec,omrPTHR,omrRTHR,rr=rrNP1_vec,mr=mr,rrr=rrr,t=t)\n  \n  #calculate life years for np1\n  lifeYearsNP1 &lt;- rowSums(populationStatesNP1[,-5])\n  \n  #total and discounted costs\n  totalCostsNP1 &lt;- populationStatesNP1[,-5] %*% costVec\n  discCostsNP1 &lt;- discountFormula(totalCostsNP1,cDR,t=t)\n  #add the initial cost for NP1\n  iCostNP1 &lt;- cNP1*1000\n  #Utility\n  totalQualityNP1 &lt;- populationStatesNP1[,-5] %*% utility\n  QALYNP1 &lt;- discountFormula(totalQualityNP1,discRate = oDR,t=t)\n  \n  #calculate the total cost for all cycles/person\n  NP1cost &lt;- sum(c(iCostNP1,discCostsNP1))/1000\n  NP1LYs &lt;- sum(lifeYearsNP1)/1000\n  NP1QALYS &lt;- sum(QALYNP1)/1000\n  \n  #returns a list of discounted cost and QALYs for each method\n  return(list(STDcost = STDcost, STDQALYS = STDQALYS, NP1cost = NP1cost,NP1QALYS = NP1QALYS, ICER = (NP1cost-STDcost)/(NP1QALYS-STDQALYS)))\n  \n}",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Exercises/Ch5-Exercise-57.html#part-1-setting-up-the-analysis",
    "href": "Exercises/Ch5-Exercise-57.html#part-1-setting-up-the-analysis",
    "title": "Exercise 5.7",
    "section": "",
    "text": "Now we will create our simulation function.\nWe start by initializing a dataframe to store our results, then iterating through each parameter and running our analysis function. This could be created using lapply, however it is probably easier to view the logic by using a for-loop.\nThis simulation function will encapsulate all statistics (functions of the data) or almost all values necessary to calculate the cost-effectiveness. However, due to R’s vectorization, and the fact that the cost effectiveness metrics are functions of other columns. We could alternatively calculate many of the metrics after the simulation is completed using R’s vectorization.\nIn the following Code:\n\n\nNMB refers to “Net Monetary Benefit”\n\nCE refers to “Cost effective”\n\nCreate our simulation function here:\n\ngenerateSimulations &lt;- function(nReps = 1000,age=60,male=0,cRatio = 100000){\n   \n   #we need to know how many columns or variable we have here in ncol\n   cols &lt;- c(\"omrPTHR\",\"omrRTHR\",\"rrNP1\",\"rrr\",\"lambda\",\"gamma\",\n             \"cPrimary\",\"cRevision\",\"cSuccess\",\"uSuccessP\",\"uSuccessR\",\n             \"uRevision\",\"cRatio\",\"STDCost\",\"STDQALYS\",\"NP1Cost\",\"NP1QALYS\",\n             \"STDNMB\",\"NP1NMB\",\"NP1Inc\",\"CESTD\",\"CENP1\",\"CENP1Inc\")\n   \n   \n   \n   dfReturn &lt;- data.frame(matrix(NA,nrow = nReps,ncol = length(cols)))\n  \n   #fill out the column names for our dataframe\n   colnames(dfReturn) &lt;- cols\n\n   #cRatio is fixed at 100000\n   #This is the threshold ratio\n   dfReturn$cRatio &lt;- cRatio\n   alpha &lt;- (5294/1487)^2\n   beta &lt;- 1487^2 / 5294\n   \n   #due to R's vectorization, we can sample all the parameters at once in the \"n\" parameter\n   omrPTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following primary THR\n   omrRTHR &lt;- rbeta(nReps,2,98) #operative mortality rate following revision THR\n   rrr &lt;- rbeta(nReps,4,96) #re-revision risk\n   \n   #save them here using R's vectorization\n   dfReturn$omrPTHR &lt;- omrPTHR\n   dfReturn$omrRTHR &lt;- omrRTHR \n   dfReturn$rrr &lt;- rrr\n   \n   #cost and utility\n   cRevision &lt;- rgamma(nReps,shape = alpha,scale = beta)\n   uSuccessP &lt;- drawBetaMethodMoments(nReps,0.85,0.03)\n   uSuccessR &lt;- drawBetaMethodMoments(nReps,0.75,0.04)\n   uRevision &lt;- drawBetaMethodMoments(nReps,0.3,0.03)\n   \n   dfReturn$cRevision &lt;- cRevision\n   dfReturn$uSuccessP &lt;- uSuccessP\n   dfReturn$uSuccessR &lt;- uSuccessR\n   dfReturn$uRevision &lt;- uRevision \n   \n   #draw from multivariate normal\n   normDraw &lt;- mvrnorm(nReps, mu = survModelSummary$coefficient,Sigma = covMat)\n   \n   #using R's vectorization, we can calculate operations on the entire vector, we must use [,\"name\"]as normDraw is not a matrix rather than a vector\n   lambda &lt;- exp(normDraw[,'cons'] + normDraw[,'age']*age + normDraw[,'male']*male)\n   gamma &lt;- exp(normDraw[,'lngamma'])\n   rrNP1 &lt;- exp(normDraw[,'NP1'])\n   \n   dfReturn$lambda &lt;- lambda\n   dfReturn$gamma &lt;- gamma\n   dfReturn$rrNP1 &lt;- rrNP1\n\n  #start the for-loop\n  \n  for(i in 1:nReps){\n    \n    #call the analysis function and specify the iteration for the parameter to be selected\n    #those with a parameter that is constant do not need to be called from dfReturn\n    results &lt;- analysisNP1(dfReturn$omrPTHR[i],dfReturn$omrRTHR[i],mr,dfReturn$rrr[i],dfReturn$rrNP1[i],\n                           dfReturn$cPrimary[i],dfReturn$cRevision[i],dfReturn$cStandard[i],dfReturn$uSuccessP[i],\n                           dfReturn$uSuccessR[i],dfReturn$uRevision[i],cDR,oDR,cNP1,dfReturn$gamma[i],dfReturn$lambda[i],iVec,t)\n    \n    #save the results\n    dfReturn$STDCost[i] &lt;- results$STDcost\n    dfReturn$STDQALYS[i] &lt;- results$STDQALYS\n    dfReturn$NP1Cost[i] &lt;- results$NP1cost\n    dfReturn$NP1QALYS[i] &lt;- results$NP1QALYS\n    \n    #calculate net monetary benefit\n    dfReturn$STDNMB[i] &lt;- results$STDQALYS*dfReturn$cRatio[i]-results$STDcost\n    dfReturn$NP1NMB[i] &lt;- results$NP1QALYS*dfReturn$cRatio[i]-results$NP1cost\n    dfReturn$NP1Inc[i] &lt;- (results$NP1QALYS-results$STDQALYS)*dfReturn$cRatio[i] - (results$NP1cost-results$STDcost)\n    \n    #calculate the cost effectiveness\n    dfReturn$CESTD[i] &lt;- ifelse(dfReturn$STDNMB[i]&gt;= dfReturn$NP1NMB[i],1,0)\n    dfReturn$CENP1[i] &lt;- ifelse(dfReturn$CESTD[i]==1,0,1)\n    dfReturn$CENP1Inc[i] &lt;- ifelse(dfReturn$NP1Inc[i]&gt;0,1,0)\n    \n    #the above formulae come directly from the textbook 5.1.4\n  }\n  return(dfReturn)\n}",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Exercises/Ch5-Exercise-57.html#part-2-calling-our-simulation-function-plotting-our-cost-effectiveness-plane",
    "href": "Exercises/Ch5-Exercise-57.html#part-2-calling-our-simulation-function-plotting-our-cost-effectiveness-plane",
    "title": "Exercise 5.7",
    "section": "Part 2: Calling our simulation function & plotting our cost-effectiveness plane",
    "text": "Part 2: Calling our simulation function & plotting our cost-effectiveness plane\nIn this section we will be using ggplot2 to plot our results. ggplot2 is generally the plotting package of choice in R and has it own unique syntax. If you don’t have ggplot2 installed, you can install it using install.packages(\"ggplot2\")\n\n\n\n\n\n\nTip\n\n\n\nWe suggest briefly reviewing https://ggplot2.tidyverse.org/articles/ggplot2.html to get a sense of how ggplot2 works. We will provide the syntax here.\n\n\nWe will begin by loading the ggplot2 library and setting our starting seed.\n\nlibrary(ggplot2)\n\nset.seed(1)\n\nWe can call the simulation by specifying any number of repetitions after the nReps = argument\n\nres &lt;- generateSimulations(nReps = 1000)\n\nNow we will quickly create the difference in costs and difference in QALYs for each intervention.\nBecause we have access to all columns we can quickly perform vector operations on them.\n\nres$diffCost &lt;- res$NP1Cost-res$STDCost\nres$diffQALYs &lt;- res$NP1QALYS-res$STDQALYS\n\nWe will use these calculations to create a plot using ggplot2\nThe syntax takes a bit of getting used to but the plots are generally quite pretty.\n\nggplot(res,\n       aes(\n         x = diffQALYs,\n         y = diffCost)) + \n      geom_point(\n        colour = \"#414487\") + \n      theme_minimal() + \n      labs(\n        x = \"QALYs\", \n        y = \"Cost\", \n        title = \"Increase in Cost Effectiveness Plane\")",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Exercises/Ch5-Exercise-57.html#part-3-adding-a-threshold",
    "href": "Exercises/Ch5-Exercise-57.html#part-3-adding-a-threshold",
    "title": "Exercise 5.7",
    "section": "Part 3: Adding a threshold",
    "text": "Part 3: Adding a threshold\nLet’s analyse the proportion of our simulation based on the threshold ratio that we specified earlier of $100,000/QALY.\nLet’s also consider changing the threshold value by looping through various possibilities.\n\n#mean proportion of STD cost effective\nmean(res$CESTD)\n\n[1] 0.001\n\n#mean proportion of NP1 cost effective\nmean(res$CENP1)\n\n[1] 0.999\n\n#equivalently, the same NP1 net monetary benefit as the \"increase\" over the standard\nmean(res$CENP1Inc)\n\n[1] 0.999\n\n\nThe NP1 implant is chosen over the standard implant 99.9% of the time with a cost threshold of $100,000/QALY.\nWhat if instead we want to see what happens if we plot this threshold value from 0 to 100,000? We can estimate this numerically by running our simulation many times for different values of cRatio and plotting the results\n\ncRatios &lt;- seq(0, 100000, by = 2500)\n\nTo loop through the cRatios and calculate the proportion of cost effectiveness we can write another for-loop or… instead since cRatios is a vector, we can use sapply to quickly loop through the vector and calculate the proportion output from the resultsNP1() function.\n\ncRatioResults &lt;- sapply(cRatios,function(x){\n  \n  #call the simulation\n  NP1sim &lt;- generateSimulations(nReps = 1000,cRatio = x)\n  \n  #calculate the proportion for each simulatiom\n  propNP1CE &lt;- mean(NP1sim$CENP1)\n  \n  return(propNP1CE)\n})\n\nncRatios &lt;- length(cRatios)\n\ndfcRatios &lt;- data.frame(cRatio = cRatios,probCENP1 = cRatioResults,probCESTD = 1-cRatioResults)\n\nNow we can plot our results using ggplot2.\n\nggplot(dfcRatios,\n       aes(\n         x = cRatio,\n         y = probCENP1)) + \n      geom_line(\n        colour = '#414487',\n        linewidth = 1.2) + \n      theme_minimal()+ \n      labs(\n        x = \"Value of ceiling ratio\", \n        y = \"Probability of cost-effective of NP1 treatment\", \n        title = \"Probability of cost-effective by value of ceiling ratio\",\n        colour = \"Treatment\")",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  },
  {
    "objectID": "Exercises/Ch5-Exercise-57.html#part-4-examining-subgroups",
    "href": "Exercises/Ch5-Exercise-57.html#part-4-examining-subgroups",
    "title": "Exercise 5.7",
    "section": "Part 4: Examining subgroups",
    "text": "Part 4: Examining subgroups\nUp to this point, we have only been looking at one age category and one gender. Let’s now build a function that loops through all possible combinations of age and gender and evaluate the proportion of cost-effectiveness treatment of NP1.\nInstead of using the convenient sapply() as in the previous part, we will use a for-loop to explicitly show which intersection of the subgroup is being analyzed.\nWe’ll start by specifying our subgroups of interest\n\nages &lt;- c(40,60,80)\ngender &lt;- c(0,1)\n\nNow, all possible combinations of these values can be easily calculated using expand.grid, note we also want all possible ceiling ratios (cRatios).\n\nfactorsOfInterest &lt;- expand.grid(cRatio = cRatios, age=ages, male = gender)\n\nWe want to add the column that we will hold our results\n\nfactorsOfInterest$propNP1CE &lt;- NA\n\nWe will then loop through the grid and perform the simulation on each row. Below we specify our function,\n\nsubGroupSimulation &lt;- function(nReps,factorsOfInterest){\n   \n  #calculate the number of combinations\n  nCombinations &lt;- nrow(factorsOfInterest)\n  \n  for(c in 1:nCombinations){\n  \n  #our current combination of the loop (current row)\n  currentCombination &lt;- factorsOfInterest[c,]\n  \n  #call our simulation function\n  NP1sim &lt;- generateSimulations(nReps = nReps, cRatio = currentCombination$cRatio ,age = currentCombination$age, male = currentCombination$male)\n  \n  #calculate the proportion of cost effectiveness\n  propNP1CE &lt;- mean(NP1sim$CENP1)\n  \n  #fill in the dataframe with the proportion\n  factorsOfInterest$propNP1CE[c] &lt;- propNP1CE\n  }\n  \n  return(factorsOfInterest)\n  \n}\n\nNow we’ll use our function to calculate our results\n\nsubGroupResults &lt;- subGroupSimulation(1000,factorsOfInterest)\n\nTo make plotting easier, we will combine the age and gender columns so that they are in one variable\n\nsubGroupResults$combined_factor &lt;- interaction(as.factor(subGroupResults$age),as.factor(subGroupResults$male),sep = \"_\")\n\nWe will again plot the results using ggplot2. This time, we manually change the names of the subgroups to provide appropriate labels in our graph.\n\n\n\n\n\n\nTip\n\n\n\nYou can specify colours for your graph by writing the colour names directly (e.g., “blue”) or by entering hex codes as we have here. In this example, we’ve used 6 colours from the viridis colour palette because it is an accessible color palette and renders well in grey scale. https://search.r-project.org/CRAN/refmans/viridisLite/html/viridis.html\n\n\n\nggplot(subGroupResults,\n       aes(\n         x = cRatio,\n         y = propNP1CE,\n         colour = combined_factor)) + \n      geom_line(\n        linewidth = 1.2,\n        alpha = 0.8) + \n      labs(\n        x = \"Threshold Ratio\", \n        y = \"Proportion of NP1 cost effective\", \n        title = \"Line plot of cost effectiveness of NP1 implant by age and gender\", \n        colour = 'Factor') +\n      scale_color_manual(\n        labels = c(\"40_0\"=\"Female Age 40\",\"60_0\"= \"Female Age 60\",\"80_0\"=\"Female Age 80\", \"40_1\"=\"Male Age 40\",\"60_1\"= \"Male Age 60\",\"80_1\"=\"Male Age 80\"),\n        values = c(\"40_0\" = \"#fde725\",\"60_0\" = \"#7ad151\",\"80_0\" = \"#22a884\", \"40_1\" = \"#2a788e\", \"60_1\" = \"#414487\",\"80_1\" = \"#440154\"))",
    "crumbs": [
      "Decision Modeling for Health Economic Evaluation",
      "Exercise 5.7"
    ]
  }
]